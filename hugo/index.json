[
{
	"uri": "https://chrilves.github.io/hugo/posts/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://chrilves.github.io/hugo/types/3-products/",
	"title": "Episode 3 - Products",
	"tags": [],
	"description": "",
	"content": " Products, often called tuples, records or case classes, are a convenient way to bundle values of different types into a single value. The product of n types (with n being 0, 1, 2, etc) A_1, A_2, \u0026hellip;, A_n is precisely the type whose values are formed with exactly one value of each type A_i for 1 ≤ i ≤ n. It is written (A_1, A_2, ..., A_n) in many languages, Product_n[A_1, A_2, ..., A_n] in Scala and A_1 × ... × A_n in Type Theory. As an example, the product of two types A and B would be defined as\nfinal case class Product2[A, B](a: A, b: B) { def fold[R](f: (A, B) =\u0026gt; R): R = f(a,b) }data Product2 a b = Constructor a b Although in practice this is the preferred way to define the product of two types A and B, we will in this presentation prefer the equivalent definition below:\nsealed abstract class Product2[A,B] { def fold[C](f: (A, B) =\u0026gt; C): C = this match { case Constructor(a,b) =\u0026gt; f(a,b) } } final case class Constructor[A,B](a: A, b: B) extends Product2[A,B]data Product2 a b where Constructor :: a -\u0026gt; b -\u0026gt; Product2 a b This equivalent definition makes clear the distinction between the type Product2[A,B] and the constructor Constructor[A,B]. the constructor is a function taking as argument one value of type A, another value of type B and returning a value of type Product2[A,B]. Its type in Haskell is A -\u0026gt; B -\u0026gt; Product2 A B and in Scala (A, B) =\u0026gt; Product2[A,B]. Note than in Scala functions of type (A, B) =\u0026gt; C are functions of two arguments (precisely Function2[A,B,C]) and not of one argument (A,B) (which would be Function1[(A,B), C]):\nscala\u0026gt; Constructor[Int, String] _ : ( (Int, String) =\u0026gt; Product2[Int, String] ) res0: (Int, String) =\u0026gt; Product2[Int,String] = $$Lambda$1620/2032136633@55be2608Prelude\u0026gt; :t Constructor Constructor :: a -\u0026gt; b -\u0026gt; Product2 a b Besides, by definition constructors are injective functions, which means that for any values a1:A, a2:A, b1:B and b2:B, Constructor[A,B](a1,b1) == Constructor[A,B](a2,b2) if and only if a1 == a2 and b1 == b2 $$\\forall a1,\\ a2:\\texttt{A},\\ b1,\\ b2:\\texttt{B},\\quad \\texttt{Constructor[A,B]}(a1,b1) = \\texttt{Constructor[A,B]}(a2,b2) \\Longleftrightarrow a1 = a2 \\textbf{ and } b1 = b2$$\nBesides, Constructor[A,B] being the only constructor of Product2[A,B] then for any value v of type Product2[A,B], there is a unique value a of type A and a unique value b of type B such that v = Constructor[A,B](a,b) $$\\forall v:\\texttt{Product2[A,B]}\\ \\exists!\\ (a:\\texttt{A} \\textrm{ and } b:\\texttt{B}),\\quad v = \\texttt{Constructor[A,B]}(a,b)$$\nEquivalence of inductive and functional forms Once again any product can be equivalently expressed as a data type Product_n_Ind[A_1, ..., A_n] and as a function type Product_n_Fun[A_1, ..., A_n] with inverse functions ind2fun and fun2ind converting back and forth types Product_n_Ind[A_1, ..., A_n] and Product_n_Fun[A_1, ..., A_n]. For example with n = 2:\nsealed abstract class Product2Ind[A,B] final case class ConstructorInd[A,B](a: A, b: B) extends Product2Ind[A,B] trait Product2Fun[A,B] { def fold[C](f: (A, B) =\u0026gt; C): C } def constructorFun[A,B](a: A, b: B): Product2Fun[A,B] = new Product2Fun[A,B] { def fold[C](f: (A, B) =\u0026gt; C): C = f(a, b) } def ind2fun[A,B]: Product2Ind[A,B] =\u0026gt; Product2Fun[A,B] = (i: Product2Ind[A,B]) =\u0026gt; i match { case ConstructorInd(a,b) =\u0026gt; constructorFun(a,b) } def fun2ind[A,B]: Product2Fun[A,B] =\u0026gt; Product2Ind[A,B] = (f: Product2Fun[A,B]) =\u0026gt; f.fold[Product2Ind[A,B]](ConstructorInd[A,B] _)data Product2Ind a b where ConstructorInd :: a -\u0026gt; b -\u0026gt; Product2Ind a b type Product2Fun a b = forall c. (a -\u0026gt; b -\u0026gt; c) -\u0026gt; c constructorFun :: a -\u0026gt; b -\u0026gt; Product2Fun a b constructorFun a b f = f a b ind2fun :: Product2Ind a b -\u0026gt; Product2Fun a b ind2fun (ConstructorInd a b) = constructorFun a b fun2ind :: Product2Fun a b -\u0026gt; Product2Ind a b fun2ind f = f ConstructorInd Generalization to a product of any number of types The definition of Product2 above can be adapted to Product_n[A_1, ..., A_n] for any value of n (i.e. 0, 1, 2, 3, 4, \u0026hellip;). With n = 0, which means a product of zero types, the constructor takes zero argument, which means it is a constant. Thus Product_0 is equivalent to Unit (i.e. Product_0 ≅ Unit). This is the reason why Unit is sometimes written (). With n = 1, Product_n[A] ≅ A.\nFurther more for any types A, B and C we have the following properties\n (A , B) is equivalent to (B , A) ((A, B), C) and (A, (B, C)) and (A, B, C) are all equivalent (Unit, A) and (A, Unit) and A are all equivalent (A) is equivalent to A (False, A) and (A, False) and False are all equivalent  Exercise: write conversion functions from and tofor each of these equivalence, such that from and to are inverse functions.\nNext Episode: CoProducts In the next episode, we will a convenient way to express alternatives: CoProducts.\n"
},
{
	"uri": "https://chrilves.github.io/hugo/types/",
	"title": "Introduction to Types",
	"tags": [],
	"description": "",
	"content": "Why using types? When are they useful? Why we should care about types? What are types? These are the questions [this series of posts]/types/ give some answers to.\n"
},
{
	"uri": "https://chrilves.github.io/hugo/types/1-why/",
	"title": "Episode 1 - Why Types?",
	"tags": [],
	"description": "",
	"content": " Why using types? When are they useful? Why we should care about types? What are types? These are the questions [this series of posts]/types/ give some answers to. Let\u0026rsquo;s start by realizing a fundamental fact: types are everywhere! Business models are all about types: users, shipments, orders, etc. Placing a user in the cart or shipping a client just makes no sense. Types are specification, discriminating what makes sense from what makes not.\nA real life example They can be simple like the well known strings, integers, booleans, lists, chars and floating-point numbers. But these six are far from covering the whole picture. Take as an example, a business application about finding the best deal amount a list of prices expressed in various currencies. To do so it would need currency conversion rates. Which data structure would you use to store these rates? One euro (EUR) worths when i write these lines 1.13 dollars (USD) which i could represent as the triple (\u0026quot;EUR\u0026quot;, 1.13 ,\u0026quot;USD\u0026quot;). To store many rates, using a list is straightforward:\nscala\u0026gt; val rates = List( (\u0026#34;EUR\u0026#34;, 1.13, \u0026#34;USD\u0026#34;), (\u0026#34;GBP\u0026#34;, 142.79, \u0026#34;JPY\u0026#34;) ) rates: List[(String, Double, String)] = List((EUR,1.13,USD), (GBP,142.79,JPY)) Are you sure the type (String, Double, String) is a faithful representation for rates? Among all the possible values of this type is (\u0026quot;EUR\u0026quot;, -3.0, \u0026quot;USD\u0026quot;) meaning when you give one euro, you have to pay three dollars more to get nothing. This is silly, currency trading don\u0026rsquo;t work that way. Another problematic value is (\u0026quot;EUR\u0026quot;, 0, \u0026quot;USD\u0026quot;). What is the point in exchanging one euro for nothing? Using Double to encode rates is wrong as not all floating point number makes a valid rate, only those strictly positive! A faithful representation of rates is the type r:Double{r \u0026gt; 0} which is the types of value r:Double such that r \u0026gt; 0. Such types are called refinement types and used heavily in F*.\nWe\u0026rsquo;re not done yet! Are you sure String is faithful representation of currencies? The empty string \u0026quot;\u0026quot; is not a currency, neither are \u0026quot;⛱\u0026quot;, \u0026quot;⛏\u0026quot;, etc but they are all valid strings. Assuming currencies:Set[String] is the set of all valid currency names, the type of currencies would be cur:String{currencies.contains(cur)} if it was expressible in Scala. But it is in F*:\nopen FStar.Set val currencies: set string let currencies = Set.as_set [\u0026#34;EUR\u0026#34;; \u0026#34;USD\u0026#34;; \u0026#34;JPY\u0026#34;] type currency = cur:string{Set.mem cur currencies} For the rest of this section, we will assume Scala has refinement types so that we can write:\ntype Rate = r:Double{r \u0026gt; 0} val currencies: Set[String] = Set(\u0026#34;EUR\u0026#34;, \u0026#34;USD\u0026#34;, \u0026#34;JPY\u0026#34;) type Currency = cur:String{currencies.contains(cur)} We\u0026rsquo;re still not done yet as the type (Currency, Rate, Currency) still does not faithfully encode a conversion rate: (\u0026quot;EUR\u0026quot;, 2.0, \u0026quot;EUR\u0026quot;) is a value of this type but one euro can not worth two euros, this would not make sense! We could define the type Rate such that the only possible value is 1.0 when there is the same currency on both sides, but for simplicity\u0026rsquo;s sake and without loss of generality, we will just forbid converting into the same currency. Once again, in a version of Scala with refinement and dependent types, conversion rates would be:\nfinal case class ConvRate( from: Currency, rate: Rate, to:Currency{from != to} ) We\u0026rsquo;re almost there! Now every value of ConvRate makes sense from a business perspective: currencies from and to are valid distinct currencies and rate is a strictly positive exchange rate. Does the type List[ConvRate] faithfully represents a valid set of conversion rates? Values like List(ConvRate(\u0026quot;EUR\u0026quot;, 2.0, \u0026quot;USD\u0026quot;), ConvRate(\u0026quot;EUR\u0026quot;, 1.13, \u0026quot;USB\u0026quot;)), where there are several distinct rates for the same conversion, do not make sense. Likewise, there is a relation between a conversion rate and its opposite direction. If one euros worth 1.13 dollars, then one dollar worths 0.88 euros. Values like List(ConvRate(\u0026quot;EUR\u0026quot;, 1.13, \u0026quot;USD\u0026quot;), ConvRate(\u0026quot;USD\u0026quot;, 2.0, \u0026quot;EUR\u0026quot;)) do not respect this rule, so are invalid business values. To be sure values do respect these business rules we can use the data structure Map and only allow one side of the conversion (from \u0026lt; to) in the type ConversionRates:\nval currencies: Set[String] = Set(\u0026#34;EUR\u0026#34;, \u0026#34;USD\u0026#34;, \u0026#34;JPY\u0026#34;) final case class Conversion( from: String{currencies.contains(from)}, to: String{currencies.contains(to) \u0026amp;\u0026amp; from \u0026lt; to } ) type ConversionRates = Map[Conversion, rate:Double{rate \u0026gt; 0}] The type ConversionRates is certainly more complex than List[(String, Double, String)] but we gained several major benefits:\n every piece of code taking ConversionRates values as input is sure they respect business rules. every piece of code outputting ConversionRates values is guaranteed to respect business rules. division by zero is impossible!  no need to check! no risk of exceptions! no need to write tests! no need to test the tests!   Conclusion You may think you are such an excellent developer than all of this is useless because you would never define a negative rate or an empty string currency. But how could you be sure that the previous developers on the project were as perfect as you? Have you written the thousands of tests required to reach the same level of confidence types provide? Will you be happy refactoring those thousands of test every time the specification change? Are you sure you know perfectly every one of the millions ones of the project? Even the one you never had to work with?\nIf we were as good as we think we are, there would not be null pointer exceptions, segfaults, exploits, undefined-is-not-a-function, java.util.NoSuchElementException: None.get and all the other so common bugs and vulnerabilities we see far too often! Software are complex beasts, made usually by many people, some who leave, some who join. Relying of people being perfect (perfect knowledge, perfect understanding, perfect execution) is not realistic.\nYou can see type systems as powerful linters whose job is to check your code. Types get more and more complex as business rules do from simple properties to heavy mathematical theorems.\nTypes are specification, so in an ideal world a program well-typed would be, by definition, a program without bugs. If you still find bugs in your application, it either means you need to tighten your types to fit the specification or your language\u0026rsquo;s type-system is not expressive enough to encode the specification.\nNext Episode In the next episode, we will see enumerations like you probably have never seen them before.\n"
},
{
	"uri": "https://chrilves.github.io/hugo/types/2-enums/",
	"title": "Episode 2 - Enumerations",
	"tags": [],
	"description": "",
	"content": " Now that we know what types are and why there are useful, it is about time to meet some remarkable ones. But before we start, there is some important things to state. As a developer i know how tempting it is to search ready-to-paste answers. But the subject of these post series is nothing like a ready-to-paste answers cookbook. On the contrary, this is a presentation of deep, difficult but rewarding concepts. Do not see them as patterns to follow blindly, like it is unfortunately too often the case in our field. Instead, take the time to develop a deep understanding of what is really going on.\nAs such, the example i give may look simple. They are indeed much simpler than in real-life applications. They are not meant to be applicable as-is but to shed light on the core ideas. If you understand the principles they rely on, you\u0026rsquo;ll be able to apply these powerful concepts in your day to day code. Do not skim through this but take the time to develop your understanding.\nIn this whole series is we will assume null (in Scala), undefined (in Haskell) and side-effects do not exist. null, undefined and side-effects are absurd in every possible way. They make interesting properties collapse and should be avoided at all costs! We will consider all functions from A to B to be mathematical functions:\n they always return a valid value of type B of any input input value of type A on the same argument (or an equal argument), they always return the same result (or an equal result) the only effect of executing them is obtaining a result, no side-effect allowed If b:B = f(a:A) we can always replace b by f(a) and vice-versa, anywhere in the program, without altering its behavior (apart from computation time and memory consumption)  Formally it means we will consider all functions referentially transparent and total. That being said, let the journey begin with a very useful concept.\nMany equivalent ways to express it There is often many ways to express the same idea. How would you represent a piece of text? The types List[Char] and String are two different ways to do so. These types are indeed not equal: they are not encoded the same way and have distinct performance properties. But despite their differences, they can be considered equivalent. There is indeed a one-to-one correspondence between them: we can define two functions list2string: List[Char] =\u0026gt; String and string2list: String =\u0026gt; List[Char]:\ndef list2string: List[Char] =\u0026gt; String = (l:List[Char]) =\u0026gt; l.foldLeft(\u0026#34;\u0026#34;) { case (str,char) =\u0026gt; s\u0026#34;$str$char\u0026#34; } def string2list: String =\u0026gt; List[Char] = (str: String) =\u0026gt; str.toList such that list2string and string2list are the inverse of each other $$\\forall s:\\texttt{String},\\quad \\texttt{string2list}(\\texttt{list2string}(s)) = s$$ $$\\forall l:\\texttt{List[Char]},\\quad \\texttt{list2string}(\\texttt{string2list}(l)) = l$$\nwhich also means\n for any list there is a unique string $$\\forall l:\\texttt{List[Char]}\\ \\exists! s:\\texttt{String} ,\\quad \\texttt{string2list}(s) = l$$\n for any string there is a unique list $$\\forall s:\\texttt{String}\\ \\exists! l:\\texttt{List[Char]},\\quad \\texttt{string2list}(\\texttt{list2string}(s)) = s$$\n list2string and string2list are injective $$\\forall l1, l2:\\texttt{List[Char]},\\ \\texttt{list2string}(l1) = \\texttt{list2string}(l2) \\implies l1 = l2$$ $$\\forall s1, s2:\\texttt{String},\\ \\texttt{string2list}(s1) = \\texttt{string2list}(s2) \\implies s1 = s2$$\n  Basically it means we can always convert from one type to the other without loss of generality.\n For any function f: A =\u0026gt; B (i.e. from A to B), f is called a bjection if and only if there exists a function g: B =\u0026gt; A (i.e. from B to A) such that f and g are inverse of each other: $$\\forall a:\\texttt{A},\\quad \\texttt{g}(\\texttt{f}(a)) = a$$ $$\\forall b:\\texttt{B},\\quad \\texttt{f}(\\texttt{g}(b)) = b$$ Two types A and B are called equivalent, which is written A ≅ B, if and only if there exists a bijection f: A =\u0026gt; B.\n This notion is fundamental as it tells us that similarity between types is how closely they behave, not how closely they look. Two types of apparent very different form may actually be equivalent while two whose form may seem close may be fundamentally at odds. Focus on properties, not on looks.\nThe empty type The first type i want to present has many names. Scala names it Nothing, Elm calls it Never, Coq uses the name it usually has in Proof Theory which is False while Type Theory refers to it as 0. This is an uninhabited type which means there is no value of this type. You may look at it as the empty set (hence the name 0):\nfinal abstract class False { def fold[A]: A } This class being final we cannot define sub-classes, but being also abstract we cannot instantiate it either! And even if we could, how would we write a function fold which meets the specification that it provides a value of type A for any A? Remember, null does not exists.\nHow a type without values can be useful? By representing impossible cases in the type-system. Let v be a value of type Either[False, Int]. v has to be Right(i) for some integer i because otherwise it would be Left(f) for some value f of type False which is impossible! It means the following pattern-matching is exhaustive.\ndef extractRight[A](v: Either[False,A]): A = v match { case Right(a) =\u0026gt; a } Unfortunately Scala protests it\u0026rsquo;s not, demanding we cover the case v = Left(f: False) by returning a value of type A. We know, assuming null does not exists, there can not be such a value f:False. How to make Scala happy? Fortunately, every hypothetical value of type False comes with a handy fold function able to return anything. It corresponds in logic to the principle of explosion stating that from a contradicton (having a value of an empty type for example), you can conclude anything:\ndef extractRight[A](v: Either[False,A]): A = v match { case Right(a) =\u0026gt; a case Left(f) =\u0026gt; f.fold[A] } Note that extractRight and Right:A =\u0026gt; Either[False, A] being inverse functions it means Either[False, A] is equivalent to A. This one is of the main properties of False: Either[False, A], Either[A, False] and A are all equivalent (i.e. Either[False, A] ≅ A ≅ Either[A, False]).\nYou could argue using Either[False, A] is pointless as it is equivalent to A which is true, but bare in mind it is just a toy example. A more realistic one would involve complex types such as bifunctors like IO[E,A]. The ability to express impossible cases let us write IO computations that never fails IO[False, A] and IO computation that never returns IO[E,False] with the same code and API instead of relying on code/API duplication which is a waste of time, effort and complexity.\nThe idea being False can be expressed in many equivalent ways. The three types False, FalseInd and FalseFun are equivalent (`False ≅ FalseInd ≅ FalseFun):\nfinal abstract class FalseInd trait FalseFun { def fold[A]: A } This is even clearer in Haskell as shown below where ind2fun and fun2ind are inverse functions.\n{-# LANGUAGE RankNTypes, EmptyCase #-} module Iso where data FalseInd type FalseFun = forall a. a ind2fun :: FalseInd -\u0026gt; FalseFun ind2fun x = case x of { } fun2ind :: FalseFun -\u0026gt; FalseInd fun2ind x = x In Scala like in Haskell FalseInd express the idea of a data type with no constructor (i.e. to way to build a value) while FalseFun is the type of a function with no argument (i.e. a constant) returning values of type A for any A, but such a function does not exists. It may seem weird having functions between empty types but it actually makes a lot of sense: there is indeed a one-to-one correspondence between these two types as both have no values at all.\nThe singleton type Often called unit, () or 1, it is the type with only one value.\nsealed abstract class Unit { def fold[A](x: A): A = this match { case Unique =\u0026gt; x } } final case object Unique extends Unit Note that the type Unit admits one and exactly one value which is UniqueInd. UniqueInd is called a constructor of the data type Unit as it one way (the only one actually) to build a value of type Unit. Unit is useful everywhere you have to fill a value and/or a type but you actually don\u0026rsquo;t care which. For example, let v = println(\u0026quot;Hello World\u0026quot;):IO[Unit] be the value printing a message to the screen. We don\u0026rsquo;t care what the execution v returns, we are only interested into what is printed, but it still needs to return something for the program to continue.\nOnce again Unit can be equivalently expressed as both the data type UnitInd and the function type UnitFun. Indeed ind2fun and fun2ind are inverse functions showing Unit ≅ UnitInd ≅ UnitFun.\nsealed abstract class UnitInd final case object UniqueInd extends UnitInd trait UnitFun { def fold[A](x: A): A } val uniqueFun: UnitFun = new UnitFun { def fold[A](x: A): A = x } def ind2fun: UnitInd =\u0026gt; UnitFun = (i: UnitInd) =\u0026gt; i match { case UniqueInd =\u0026gt; uniqueFun } def fun2ind: UnitFun =\u0026gt; UnitInd = (f: UnitFun) =\u0026gt; f.fold[UnitInd](UniqueInd)data UnitInd where UniqueInd :: UnitInd type UnitFun = forall a. a -\u0026gt; a uniqueFun :: UnitFun uniqueFun x = x ind2fun :: UnitInd -\u0026gt; UnitFun ind2fun UniqueInd = uniqueFun fun2ind :: UnitFun -\u0026gt; UnitInd fun2ind u = u UniqueInd The type UnitFun may surprise you. How is it possible that a function type like it has only one possible value? Try to write a referentially transparent and total instance of UnitFun. You will see there is only one way to do so.\nOne of the main properties of Unit is that (Unit, A), (A, Unit) and A are equivalent (i.e. (Unit, A) ≅ A ≅ (A, Unit)). Exercise: write the inverse functions between these types.\nThe two values type: Booleans Here comes one of the most well known type: the one with exactly two values often called Boolean in programming and 2 in Type Theory. Its values are generally named true and false:\nsealed abstract class Boolean { def fold[A](tt: A, ff: A): A = this match { case True =\u0026gt; tt case False =\u0026gt; ff } } final case object True extends Boolean final case object False extends Boolean I\u0026rsquo;m sure you\u0026rsquo;re already familiar with booleans, but did you recognize the fold function? It is generally named if-then-else:\ndef ifThenElse[A](b: Boolean)(tt: A, ff: A): A = b.fold[A](tt, ff) True and False are called the constructors of Boolean because they are the only way to build values of type Boolean. Once again this idea of a type with two values is equivalently expressed both as the data type BoolInd and as the function type BoolFun . Functions ind2fun and fun2ind are indeed inverse of each other.\nsealed abstract class BoolInd final case object TrueInd extends BoolInd final case object FalseInd extends BoolInd trait BoolFun { def fold[A](tt: A, ff: A): A } val trueFun: BoolFun = new BoolFun { def fold[A](tt: A, ff: A): A = tt } val falseFun: BoolFun = new BoolFun { def fold[A](tt: A, ff: A): A = ff } def ind2fun: BoolInd =\u0026gt; BoolFun = (i: BoolInd) =\u0026gt; i match { case TrueInd =\u0026gt; trueFun case FalseInd =\u0026gt; falseFun } def fun2ind: BoolFun =\u0026gt; BoolInd = (f: BoolFun) =\u0026gt; f.fold[BoolInd](TrueInd, FalseInd)data BoolInd where TrueInd :: BoolInd FalseInd :: BoolInd type BoolFun = forall a. a -\u0026gt; a -\u0026gt; a trueFun :: BoolFun trueFun tt _ = tt falseFun :: BoolFun falseFun _ ff = ff ind2fun :: BoolInd -\u0026gt; BoolFun ind2fun TrueInd = trueFun ind2fun FalseInd = falseFun fun2ind :: BoolFun -\u0026gt; BoolInd fun2ind u = u TrueInd FalseInd Once again the type BoolFun may surprise you. Once again try to write a referentially transparent and total instance of BoolFun. You will see there are only two ways to do so.\nI could continue forever presenting types with 3, 4, \u0026hellip; values but by now you must see the same pattern repeating and repeating again.\nNext Episode: Products In the next episode, we will a convenient way to combine types: Products.\n"
},
{
	"uri": "https://chrilves.github.io/hugo/types/4-coproducts/",
	"title": "Episode 4 - CoProducts",
	"tags": [],
	"description": "",
	"content": " CoProducts, often called sum types, discriminated unions or disjoint unions, are a convenient way to express an alternative between different types. The coproduct of n types (with n being 0, 1, 2, etc) A_1, A_2, \u0026hellip;, A_n is precisely the type whose values are (i, a_i) where i is a number, called the tag, between 1 and n both included (1 ≤ i ≤ n) and a_i is a value of type A_i (the actual type then depends on the value of i). Is is often written Either[A_1, ..., A_n] in programming and A_1 + ... + A_n in Type Theory.\nLet\u0026rsquo;s take, as an example, n = 4, A_1 = Char, A_2 = Boolean, A_3 = Char and A_4 = Double. The following values are all valid and distinct values of type Either4[Char, Boolean, Char, Double]: (1, 'C'), (2, true), (3, 'D'), (4, 3.2), (3, 'C'). Note that (1, 'C') and (3, 'C') are different values because the tag is different.\nInstead of writing the tag explicitly, programming languages often let us write n constructors: Inj_i: A_i =\u0026gt; Either_n[A_1, ..., A_n] such that $$\\forall i\\in{1,\\dots,n},\\quad \\texttt{Inj}_i : \\texttt{A}_i \\rightarrow \\texttt{Either}_n[\\texttt{A}_1,\\dots,\\texttt{A}_n]$$ $$\\forall i\\in{1,\\dots,n},\\quad \\forall a_i:\\texttt{A}_i,\\quad \\texttt{Inj}_i(a_i) = (i, a_i)$$\nNote that:\n As usual constructors are injective functions $$\\forall i\\in{1,\\dots,n},\\quad \\forall a_i,a\u0026rsquo;_i:\\texttt{A}_i,\\quad \\texttt{Inj}_i(a_i) = \\texttt{Inj}_i(a\u0026rsquo;_i) \\Leftrightarrow a_i = a\u0026rsquo;_i$$ The only way to get a value of type Either_n[A_1, ... , A_n] is by using one of the constructors $$\\forall v:\\texttt{Either}_n[\\texttt{A}_1,\\dots,\\texttt{A}_n],\\quad \\exists! i\\in{1,\\dots,n},\\quad \\texttt{Inj}_i(a_i) = v$$ Two different constructors produce different values (hense the disjoint and discriminated unions) $$\\forall i,j\\in{1,\\dots,n},\\quad \\forall a_i:\\texttt{A}_i,\\quad \\forall a_j:\\texttt{A}_j,\\quad \\texttt{Inj}_i(a_i) = \\texttt{Inj}_j(a_j) \\Leftrightarrow i = j \\textbf{ and } a_i = a_j$$  For example with n = 2, the coproduct of two types A and B is defined as\nsealed abstract class Either2[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R = this match { case Inj1(a) =\u0026gt; inj1(a) case Inj2(b) =\u0026gt; inj2(b) } } final case class Inj1[A,B](value: A) extends Either2[A,B] final case class Inj2[A,B](value: B) extends Either2[A,B] Saying the pattern matching above is exhaustive is exactly equivalent to say a value of type Either2[A,B] has to be either Inj1(a) for some a:A or Inj2(b) for some b:B. Requiring that Inj1 and Inj2 produce different values is also mandatory as Eirher2[Error, Result] is often used to model computation that may fail. A failed computation would produce a Inj1(e) with e being the error that occurred while a successful computation would produce a Inj2(r) with r the result of the computation. We want to be able to discriminate these two cases, even when the types Error and Result are the same as it is usually the case when the computation need to compute a string or fail with an error message. Likewise, the injectivity of the constructors is mandatory to be able to the result produced r or the error that occurred e.\nEquivalence of inductive and functional forms Once again any *coproductù can be equivalently expressed as a data type Either_n_Ind[A_1, ..., A_n] and as a function type Either_n_Fun[A_1, ..., A_n] with inverse functions ind2fun and fun2ind converting back and forth types Either_n_Ind[A_1, ..., A_n] and Either_n_Fun[A_1, ..., A_n]. For example with n = 2:\nsealed abstract class Either2Ind[A,B] final case class Inj1_Ind[A,B](value: A) extends Either2Ind[A,B] final case class Inj2_Ind[A,B](value: B) extends Either2Ind[A,B] trait Either2Fun[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R } def inj1_fun[A,B]: A =\u0026gt; Either2Fun[A,B] = (a: A) =\u0026gt; new Either2Fun[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R = inj1(a) } def inj2_fun[A,B]: B =\u0026gt; Either2Fun[A,B] = (b: B) =\u0026gt; new Either2Fun[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R = inj2(b) } def ind2fun[A,B]: Either2Ind[A,B] =\u0026gt; Either2Fun[A,B] = (i: Either2Ind[A,B]) =\u0026gt; i match { case Inj1_Ind(a) =\u0026gt; inj1_fun(a) case Inj2_Ind(b) =\u0026gt; inj2_fun(b) } def fun2ind[A,B]: Either2Fun[A,B] =\u0026gt; Either2Ind[A,B] = (f: Either2Fun[A,B]) =\u0026gt; f.fold[Either2Ind[A,B]](Inj1_Ind[A,B] _, Inj2_Ind[A,B] _)data Either2Ind a b where Inj1_Ind :: a -\u0026gt; Either2Ind a b Inj2_Ind :: b -\u0026gt; Either2Ind a b type Either2Fun a b = forall c. (a -\u0026gt; c) -\u0026gt; (b -\u0026gt; c) -\u0026gt; c inj1_fun :: a -\u0026gt; Either2Fun a b inj1_fun a f _ = f a inj2_fun :: b -\u0026gt; Either2Fun a b inj2_fun b _ g = g b ind2fun :: Either2Ind a b -\u0026gt; Either2Fun a b ind2fun (Inj1_Ind a) = inj1_fun a ind2fun (Inj2_Ind a) = inj2_fun a fun2ind :: Either2Fun a b -\u0026gt; Either2Ind a b fun2ind f = f Inj1_Ind Inj2_Ind Generalization to a product of any number of types The definition of Either2 above can be adapted to Either_n[A_1, ..., A_n] for any value of n (i.e. 0, 1, 2, 3, 4, \u0026hellip;). With n = 0, which means a coproduct of zero types, there is no constructor, which means it is impossible to build a value of this type. Thus Either_0 is equivalent to False (i.e. Either_0 ≅ False). With n = 1, Either_n[A] ≅ A.\nFurther more for any types A, B and C we have the following properties\n Either2[A,B] is equivalent to Either2[B,A] Either2[Either2[A,B], C] and Either2[A, Either2[B,C]] and Either3[A,B,C] are all equivalent Eithr2[False,A] and Either2[A,False] and A are all equivalent Either_1[A] is equivalent to A (C, Either2[A,B]) is equivalent to Either2[(C,A), (C,B)]  Exercise: write conversion functions from and tofor each of these equivalence, such that from and to are inverse functions.\nRemember that in Type Theory, False is written 0, Unit is written 1, the product (A_1, ..., A_n) is written A_1 × ... A_n and the coproduct Either_n[A_1, ..., A_n] is written A_1 + ... + A_n. If we express the above properties using Type Theory notation, we get\n A + B ≅ B + A (A + B) + C ≅ A + (B + C) ≅ A + B + C 0 + A ≅ A + 0 ≅ A C × (A + B) ≅ (C × A) + (C × B) 1 × A ≅ A 0 × A ≅ A × 0 ≅ 0  Is arithmetic familiar to you? If so such equations should be familiar too. But these times there are not between numbers but between equivalent types. If you ever wonder why Algebraic Data Types are called this way, this should give you some hints.\nNext Episode: Recursive Data Types In the next episode, we will see Recursive Data Types.\n"
},
{
	"uri": "https://chrilves.github.io/hugo/types/5-rectypes/",
	"title": "Episode 5 - Recursive Data Types",
	"tags": [],
	"description": "",
	"content": " We have seen many types but we still don\u0026rsquo;t know how to represent numbers, lists, trees, free monads, or any type with an infinite number of values. One again we will start by simple examples. Like always, do no skim through them but take the time to develop a deep understanding. If you feel uncomfortable with complex examples, it means you missed something important in the simple ones.\nA simple example We will take as example an encoding of non-negative integers, also called natural numbers, i.e. numbers 0, 1, 2, 3 and so on. There are actually many encodings possible, but we will take a simple encoding known as Peano numbers. Did you ever wonder how natural numbers are built? There can actually be built starting from 0 then adding 1 to 0 to make 1, then adding 1 to 1 to make 2, then adding 1 to 2 to make 3, then adding 1 to 3 to make 4, and so on. Our encoding will mimic this construction. We need two constructors: one of represent 0 and the other to represent the operation of adding 1 to the previous number to make a new one.\nLet\u0026rsquo;s call Nat the type of natural numbers. The first constructor, representing 0 should be a constant of type Nat while the second one, representing the operation of adding 1 should be a function of type Nat =\u0026gt; Nat. Remember that constructors need to be injective, but we are lucky, this operation is actually injective. Let call the first constructor Zero:Nat and the second one Succ:Nat =\u0026gt; Nat (for successor). This is easy to translate into Scala and Haskell:\nsealed abstract class Nat { def fold[A](zero: A, succ: A =\u0026gt; A): A = this match { case Zero =\u0026gt; zero case Succ(p) =\u0026gt; val a = p.fold(zero, succ) succ(a) } } final case object Zero extends Nat final case class Succ(n: Nat) extends Natdata Nat where Zero :: Nat Succ :: Nat -\u0026gt; Nat Note that all the constructors we have seen in the previous episodes took as argument already defined types, but the first argument of Succ is of type Nat, the very same type we are defining. This is the reason why Nat is called a recursive data type: some of its constructors take as arguments values of type Nat itself. As usual:\n constructors are injective different constructors produces different value every value of type Nat is either a Zero or a Succ(n) for some n:Nat  The problem is, unlike enumerations, products and coproducts where these properties are enough to define their respective type (up to equivalence) without ambiguity. With recursive data types there can be several non-equivalent types for which these three properties hold. For example, the type {0, 1, 2, ...} of natural numbers and {O, 1, 2, ..., ∞} in which we added one special number called infinity such that Succ(∞) = ∞ both have the three properties above. So wee need to add a new constraint, which is that: among all the types for which these properties hold, Nat is taken as the smallest one.\nRecursive types have amazing properties. For example the types Nat and Option[Nat] are equivalent! Indeed nat2opt and opt2nat are inverse bijections:\ndef opt2nat: Option[Nat] =\u0026gt; Nat = { case Some(n) =\u0026gt; Succ(n) case None =\u0026gt; Zero } def nat2opt: Nat =\u0026gt; Option[Nat] = { case Succ(n) =\u0026gt; Some(n) case Zero =\u0026gt; None }opt2nat :: Maybe Nat -\u0026gt; Nat opt2nat (Just n) = Succ n opt2nat Nothing = Zero nat2opt :: Nat -\u0026gt; Maybe Nat nat2opt (Succ n) = Just n nat2opt Zero = Nothing It means that Nat ≅ Option[Nat]. Note that Option[T] ≅ Either[Unit, T] ≅ 1 + T in Type Theory notation, so Nat is actually one of the solution of the type equation T ≅ 1 + T. Such an equation means we are looking for types T such that T and Option[T] are equivalent. Regarding Option as a function from types to type, where the type Option[T] is the one obtained by applying the argument T to the function Option, Nat is one of the fixed-point of this function. More precisely, Nat is the least fixed-point of Option.\n Let μ: (Type -\u0026gt; Type) -\u0026gt; Type be the operator taking a type function F as argument (written F[_] in Scala and f :: * -\u0026gt; * in haskell) and returning the least fixed-point of F, which is defined as the smallest type T (up to equivalence) which is solution of the equation T ≅ F[T]. To simplify the notations, we may also write μT.F[T] instead of μ(F).\n As an example Nat = μ(Option) which we also write Nat = μT.Either[Unit, T] and also Nat = μT.(1 + T).\nAnother solution to the equation, which is, this time the greatest fixed-point of Option is the type NatInf, representing {0, 1, 2, ..., ∞}, defined as below. It is the biggest type which is solution (up to equivalence) of the equation T ≅ 1 + T. The two inverse functions opt2natInf and natInf2opt proves the equivalence:\ntrait NatInf { def unfold: Option[NatInf] } val zero: NatInf = new NatInf { def unfold: Option[NatInf] = None } def succ(n: NatInf): NatInf = new NatInf { def unfold: Option[NatInf] = Some(n) } val ∞ : NatInf = new NatInf { def unfold: Option[NatInf] = Some(∞) } def opt2natInf: Option[NatInf] =\u0026gt; NatInf = { case Some(n) =\u0026gt; succ(n) case None =\u0026gt; zero } def natInf2opt: NatInf =\u0026gt; Option[NatInf] = (n: NatInf) =\u0026gt; n.unfoldnewtype NatInf = NatInf { unfold :: Maybe NatInf } zero :: NatInf zero = NatInf Nothing succ :: NatInf -\u0026gt; NatInf succ n = NatInf (Just n) inf :: NatInf inf = NatInf (Just inf) opt2natInf :: Maybe NatInf -\u0026gt; NatInf opt2natInf (Just n) = succ n opt2natInf Nothing = zero natInf2opt :: NatInf -\u0026gt; Maybe NatInf natInf2opt = unfold Equivalence of inductive and functional definitions Nat can be equivalently defined as a data type NatInd as well as a function type NatFun. Inverse bijections ind2fun and fun2ind prove NatInf and NarInd are equivalent:\nsealed abstract class NatInd final case object ZeroInd extends NatInd final case class SuccInd(n: NatInd) extends NatInd trait NatFun { def fold[A](zero: A, succ: A =\u0026gt; A): A } val zeroFun : NatFun = new NatFun { def fold[A](zero: A, succ: A =\u0026gt; A): A = zero } def succFun(n: NatFun) : NatFun = new NatFun { def fold[A](zero: A, succ: A =\u0026gt; A): A = { val a = n.fold[A](zero, succ) succ(a) } } def ind2fun: NatInd =\u0026gt; NatFun = (i: NatInd) =\u0026gt; i match { case ZeroInd =\u0026gt; zeroFun case SuccInd(p) =\u0026gt; val n = ind2fun(p) succFun(n) } def fun2ind: NatFun =\u0026gt; NatInd = (n: NatFun) =\u0026gt; n.fold[NatInd](ZeroInd, SuccInd(_))data NatInd where ZeroInd :: NatInd SuccInd :: NatInd -\u0026gt; NatInd type NatFun = forall a. a -\u0026gt; (a -\u0026gt; a) -\u0026gt; a zeroFun :: NatFun zeroFun z _ = z succFun :: NatFun -\u0026gt; NatFun succFun n z s = s (n z s) ind2fun :: NatInd -\u0026gt; NatFun ind2fun ZeroInd = zeroFun ind2fun (SuccInd n) = succFun (ind2fun n) fun2ind :: NatFun -\u0026gt; NatInd fun2ind n = n ZeroInd SuccInd Lists Similarly, given a type A, we want to define the the type of lists whose elements are of type A, written List[A]. Let l:List[A] be a list whose elements are of type A. There are two cases: either the list is empty or it is not. Let\u0026rsquo;s call the the empty list Nil. If the list is not empty, let head be its first element and tail the rest of the list (i.e. the same list as l but without the first element head). Then tail is also a list of type List[A] and l can be obtained by prepending head to tail. We will write this prepending operation Cons :: (A, List[A]) =\u0026gt; List[A] such that l = Cons(head, tail).\nOnce again we see we have two constructors: Nil of type List[A] and Cons of type (A, List[A]) =\u0026gt; List[A]. Besides, these constructors satisfy the usual thee properties:\n constructors are injective different constructors produces different value every value of type List[A] is either a Nil or a Cons(head, tail) for some head:A and some tail:List[A]  Furthermore List[A] is the smallest type satisfying these properties. It can easily be defined in Scala as\nsealed abstract class List[+A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R = this match { case Nil =\u0026gt; nil case Cons(head,tail) =\u0026gt; val r = tail.fold[R](nil, cons) cons(head, r) } } final case object Nil extends List[Nothing] final case class Cons[+A](head: A, tail: List[A]) extends List[A] Like any recursive data type, List[A] is the smallest solution of a type equation. This time the equation is T ≅ 1 + (A, T) which in a more Scalaish syntax is T ≅ Option[(A, T)]. Equivalently, List[A] is also the least fixed-point of the type-function:\ntype F[T] = Option[(A, T)] Which means List[A] = μT.(1 + A × T). The biggest type which is solution (up to equivalence) of the equation, which is the greatest fixed-point of F is the type of streams whose elements are of type A, written Stream[A]:\ntrait Steam[A] { def unfold: Option[(A, Stream[A])] }newtype Stream a = Stream { runStream :: forall c. (Maybe (a, Stream a) -\u0026gt; c) -\u0026gt; c } Exercise: write the bijections proving Stream[A] ≅ Option[(A, Stream[A])]\nEquivalence of inductive and functional definitions List[A] can equivalently be defined as the data type ListInd[A] as well as the type function ListFun[A]. The two inverse functions ind2fun and fun2ind prove ListInd[A] and ListFun[A] are equivalent:\nsealed abstract class ListInd[+A] final case object NilInd extends ListInd[Nothing] final case class ConsInd[+A](head: A, tail: ListInd[A]) extends ListInd[A] trait ListFun[+A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R } def nilFun[A]: ListFun[A] = new ListFun[A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R = nil } def consFun[A](head: A, tail: ListFun[A]): ListFun[A] = new ListFun[A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R = { val r = tail.fold[R](nil, cons) cons(head, r) } } def ind2fun[A]: ListInd[A] =\u0026gt; ListFun[A] = (i: ListInd[A]) =\u0026gt; i match { case NilInd =\u0026gt; nilFun[A] case ConsInd(head, tail) =\u0026gt; val tailFun = ind2fun(tail) consFun(head, tailFun) } def fun2ind[A]: ListFun[A] =\u0026gt; ListInd[A] = (f: ListFun[A]) =\u0026gt; f.fold[ListInd[A]](NilInd, ConsInd(_,_))data ListInd a where NilInd :: ListInd a ConsInd :: a -\u0026gt; ListInd a -\u0026gt; ListInd a type ListFun a = forall r. r -\u0026gt; (a -\u0026gt; r -\u0026gt; r) -\u0026gt; r nilFun :: ListFun a nilFun nil _ = nil consFun :: a -\u0026gt; ListFun a -\u0026gt; ListFun a consFun head tail nil cons = cons head (tail nil cons) ind2fun :: ListInd a -\u0026gt; ListFun a ind2fun NilInd = nilFun ind2fun (ConsInd head tail) = consFun head (ind2fun tail) fun2ind :: ListFun a -\u0026gt; ListInd a fun2ind f = f NilInd ConsInd Algebraic Data Types Algebraic Data Types are types that can be expressed using only False, Unit, products, coproducts and the least fixed-point operator μ. For example, binary trees whose elements are of type A, defined in Scala by\nsealed abstract class Tree[+A] { def fold[R](empty: R, leaf: A =\u0026gt; R, node: (R, R) =\u0026gt; R): R = this match { case Empty =\u0026gt; empty case Leaf(a) =\u0026gt; leaf(a) case Node(l, r) =\u0026gt; val al = l.fold[R](empty, leaf, node) val ar = r.fold[R](empty, leaf, node) node(al, ar) } } final case object Empty extends Tree[Nothing] final case class Leaf[+A](value: A) extends Tree[A] final case class Node[+A](left: Tree[A], right: Tree[A]) extends Tree[A] can be expressed as the type Tree[A] = μT.(1 + A + (T × T)), which is the smallest type (up to equivalence) solution of the equation T ≅ Either3[Unit, A, (T, T)].\nExercise: write the bijection proving the equivalence.\n"
},
{
	"uri": "https://chrilves.github.io/hugo/posts/folds/",
	"title": "Let&#39;s meet the charming fold family",
	"tags": [],
	"description": "Introduction to catamorphisms on Algebraic Data Types",
	"content": " Today we will meet an amazing family: the fold functions!\nThe well known foldRight Lists is one of the first data structure every developer/computer scientist meet in her/his journey into programming:\nsealed abstract class List[+A] final case object Nil extends List[Nothing] final case class Cons[+A](head: A, tail: List[A]) extends List[A] It means means values of type List[A] can be of (only) two forms:\n either Nil or Cons(head, tail) for some values head of type A and tail of type List[A]  For example we can define the following lists:\nval empty : List[Int] = Nil val l1 : List[Int] = Cons(61, Nil) val l2 : List[Int] = Cons(34, Cons(61, Nil)) val l3 : List[String] = Cons(\u0026#34;a\u0026#34;, Cons(\u0026#34;b\u0026#34;, Cons(\u0026#34;c\u0026#34;, Nil))) In addition, Nil and Cons can be seen as constants and functions returning List[A]:\ndef nil[A]: List[A] = Nil def cons[A](head: A, tail: List[A]): Lis[A] = Cons(head, tail) The fold function, often called foldRight, answers the question:\n What would have happened if, instead of having used Nil and Cons in the construction of a list l:List[A], we would have used another constant z:T and another function f:(A, T) =\u0026gt; T for some type T?\n Let\u0026rsquo;s illustrate this using the previous examples:\nval empty : Int = 0 // z = 0 val v1 : Int = max(61, 0) // z = 0, f = max val v2 : Int = mult(34, mult(61, 1)) // z = 1, f = mult val v3 : String = concat(\u0026#34;a\u0026#34;, concat(\u0026#34;b\u0026#34;, concat(\u0026#34;c\u0026#34;, \u0026#34;\u0026#34;))) -- z = \u0026#34;\u0026#34;, f = concat The definition of foldRight illustrates well the transformation process. It deconstructs the list l:List[A] and replace Nil by z and Cons by f:\ndef foldList[A,T](z: T, f: (A,T) =\u0026gt; T): List[A] =\u0026gt; T = { def transform(l: List[A]): T = l match { case Nil =\u0026gt; z case Cons(head, tail) =\u0026gt; val transformedTail = transform(tail) f(head, transformedTail) } transform _ } The simple cases: Enum Types fold functions can be defined for a wide range of data structures. As a first example, let\u0026rsquo;s take this type:\nsealed abstract class SingletonType final case object SingleValue extends SingletonType The type SingletonType admits one and only one value: SingleValue. Folding over SingletonType means, replacing SingleValue by a constant z:T for some type T :\ndef foldSingletonType[T](z:T): SingletonType =\u0026gt; T = { def transform(v: SingletonType): T = v match { case SingleValue =\u0026gt; z } transform _ } While SingletonType has only one value, the type Boolean have exactly two values True and False:\nsealed abstract class Boolean final case object True extends Boolean final case object False extends Boolean So folding over Booleans mean, given a type T and two constants tt:T and ff:T, replacing True by tt and False by ff:\ndef foldBoolean[T](tt:T, ff:T): Boolean =\u0026gt; T = { def transform(v: Boolean): T = v match { case True =\u0026gt; tt case False =\u0026gt; ff } transform _ } And so on for every enum type.\nBeyond enums You may start the see general process. If values of type C are build using constructors (Nil and Cons[A] for List[A], SingleValue for SingletonType, True and False for Boolean), then folding is all about transforming values of type C into another type T by replacing each constructor of C by a constant or function on T of the same shape. Let\u0026rsquo;s consider the type Either[A,B]:\nsealed abstract class Either[A,B] final case class Left[A,B](value: A) extends Either[A,B] final case class Right[A,B](value: B) extends Either[A,B] To transform values of type Either[A,B] into T we need two functions on T:\n Left being of type A =\u0026gt; Either[A,B] we need a function f: A =\u0026gt; T. Right being of type B =\u0026gt; Either[A,B] we need a function g: B =\u0026gt; T.  Then we can operate the transformation:\ndef foldEither[A,B,T](f: A =\u0026gt; T, g: B =\u0026gt; T): Either[A,B] =\u0026gt; T = { def transform(v: Either[A,B]): T = v match { case Left(a) =\u0026gt; f(a) case Right(b) =\u0026gt; g(b) } transform _ } Recursive Types Folding over recursive types obey the previous rules. Recursion is handled by transforming sub-terms first. Let\u0026rsquo;s consider the type of binary trees:\nsealed abstract class Tree[+A] final case object Empty extends Tree[Nothing] final case class Node[+A](value:A, left: Tree[A], right: Tree[A]) extends Tree[A] To transform values of type Tree[A] into T we need:\n Empty being a constant of type Tree[A], we need a constant z:T. Node being a function of type (A, Tree[A], Tree[A]) =\u0026gt; Tree[A] we need a function f: (A, T, T) =\u0026gt; T. Note how all occurrences of Tree[A] have been replaced by T in the type.  Then we can operate the transformation:\ndef foldTree[A,T](z: T, f: (A, T, T) =\u0026gt; T): Tree[A] =\u0026gt; T = { def transform(v: Tree[A]): T = v match { case Empty =\u0026gt; z case Node(a,l,r) =\u0026gt; val g: T = transform(l) // Transforming sub-term l  val d: T = transform(r) // Transforming sub-term r  f(a,g,d) } transform _ } Generalized Algebraic Data Types (GADT) Instead of giving a formal definition of what Generalized Algebraic Data Types i will show you some examples.\nType Equalities Consider the type:\nsealed abstract class EmptyOrSingleton[A] final case object SingleValueIfAisInt extends EmptyOrSingleton[Int] This type looks very similar to SingletonType but, while SingleValue was always a value of SingletonType, SingleValueIfAisInt is only a value of EmptyOrSingleton[Int], i.e. when A is Int. So what happens to EmptyOrSingleton[A] when A is not Int? Then there is no constructor for EmptyOrSingleton[A] so no value for SingletonIfInt[A] (excluding null which we will pretend no to exist).\nGADTs are very useful to encode predicates over types. Imagine you have a value v:EmptyOrSingleton[A] for some type A (remember we pretend null does not exist). What could you say about A? The only way to get a value of type EmptyOrSingleton[A] is through SingleValueIfAisInt. Thus v is SingleValueIfAisInt which is of type EmptyOrSingleton[Int] so is v. We can conclude that A is actually Int. Not convinced? Let A be String, can you build a value of type EmptyOrSingleton[String] without using null? Try it.\nTo find how to fold EmptyOrSingleton[A] into T, let\u0026rsquo;s apply the technique we used in the previous sections. EmptyOrSingleton[A] has only one constructor, SingleValueIfAisInt, so we need a constant z:T. But SingleValueIfAisInt is not of type EmptyOrSingleton[A] but EmptyOrSingleton[Int]. The argument A matters so let T depend on A: we want to transform values of type EmptyOrSingleton[A] into T[A].\n SingleValueIfAisInt being of type EmptyOrSingleton[Int] we need a constant z:T[Int]  Then we can operate the transformation:\ndef foldEmptyOrSingleton[A, T[_]](z: T[Int]): EmptyOrSingleton[A] =\u0026gt; T[A] = { def transform(v: EmptyOrSingleton[A]): T[A] = v match { case SingleValueIfAisInt =\u0026gt; z // Because we know A = Int  } transform _ } foldEmptyOrSingleton means that, for some T[_], if you have a value z:T[Int] then you can transform any value EmptyOrSingleton[A] into T[A]. For example, let\u0026rsquo;s take\ntype T[X] = X =:= Int val z:T[Int] = implicitly[Int =:= Int] Then foldEmptyOrSingleton[A,T](z) gives us, for any value v:EmptyOrSingleton[A] a proof that A =:= Int. Another important use case is asserting type equality:\nsealed abstract class Eq[A,B] final case class Refl[X]() extends Eq[X,X] Any non-null value v:Eq[A,B] must be a Refl[X]() : Eq[X,X] for some X, then Eq[A,B] = Eq[X,X] proving that A = X = B. To transform a value of type Eq[A,B] into T[A,B] we need:\n Refl[X]() is essentially a constant of type Eq[X,X] for all type X (note: Scala write this type [X]Eq[X,X]). We need a constant z:T[X,X] for all type X (so the type [X]T[X,X]). Scala does not support transparent higher-ranked types, we need to emulate them with a trait:  trait ElimRefl[T[_,_]] { def apply[X]: T[X,X] } Then we could have hoped to be able to operate the transformation like previous section. But given a value v:Eq[A,B], convincing Scala that A = B is a bit tough. Instead we can write the fold as a method:\nsealed abstract class Eq[A,B] { def fold[T[_,_]](z: ElimRefl[T]): T[A,B] } final case class Refl[X]() extends Eq[X,X] { def fold[T[_,_]](z: ElimRefl[T]): T[X,X] = z[X] } def foldEq[A, B, T[_,_]](z: ElimRefl[T]): Eq[A,B] =\u0026gt; T[A,B] = (v:Eq[A,B]) =\u0026gt; v.fold[T](z) Ingenious definition of T[_,_] leads to interesting results:\ntrait C[X] type T1[A,B] = C[A] =:= C[B] val z1: ElimRefl[T1] = new ElimRefl[T1] { def apply[X]: T1[X,X] = implicitly[C[X] =:= C[X]] } def transform[A,B]: Eq[A,B] =\u0026gt; C[A] =:= C[B] = foldEq[A,B,T1](z1) Existential Quantification GADTs not only provide useful type equalities, they also offer existential quantification!\nsealed abstract class Ex[F[_]] { type hidden val value: hidden val evidence: F[hidden] } final case class MakeEx[F[_],A](value: A, evidence: F[A]) extends Ex[F] { type hidden = A } Any value v:Ex[F] has to be an instance of MakeEx[F,A] for some type A. Which means we have a value, v.value, of type A and an instance of the type-class F for A (for example an instance of Monoid[A] with F[X] = Monoid[X]).\nTo transform values of type Ex[F] into T we need:\n MakeEx[F[_],?] being of type [A](A, F[A]) =\u0026gt; Ex[F] meaning: For_all_type A, (A, F[A]) =\u0026gt; Ex[F], we need a function f of type [A](A, F[A]) =\u0026gt; T. Scala still does not support transparent higher ranked types, we need to emulate them with another trait:  trait ElimMakeEx[F[_],T] { def apply[A](value: A, evidence: F[A]): T } Then we can operate the transformation:\ndef foldEx[F[_], T](f: ElimMakeEx[F, T]): Ex[F] =\u0026gt; T = { def transform(v: Ex[F]): T = v match { case w@MakeEx(value, evidence) =\u0026gt; f[w.hidden](value, evidence) } transform _ } Duality In this post we have deduced the fold functions from the definition of each type. It is possible to do the opposite: each constructor can be derived from the fold function of its type. For example:\ntrait List[+A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T } def nil[A]: List[A] = new List[A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T = z } def cons[A](head:A, tail: List[A]): List[A] = new List[A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T = f(head, tail.fold(z,f)) } def equality[A](l1: List[A], l2:List[A]): Boolean = ??? // Difficult but worthy exercice Conclusion I hope i convinced you folds are immensely useful. First, they let us write simply complex transform functions. But this not the most interesting property. It is sometimes easier to define a type by its fold function. Java, for example, does not have support for neither sealed classes nor pattern-matching. How could we define the List type so that Nil and Cons are the two only cases? The fold function forces any instance of List to fit into the desired shape (if some rules are obeyed like no null and no runtime-reflection). It can also happen that type-inference is not smart enough, fold function provide an alternative way which is often easier for the Scala type-checker.\n"
},
{
	"uri": "https://chrilves.github.io/hugo/posts/slimetrail/",
	"title": "How to make game in the browser thanks to ScalaJS",
	"tags": [],
	"description": "ScalaIO.2018 Workshop",
	"content": " A few month ago, the Paris Scala User Group kindly invited me present a workshop introducing [Scala.js(https://www.scala-js.org/). Even better, i will have the chance to present it in October at ScalaIO.\nI will present how to develop a web application in Scala.js. This talk is for Scala developers having a penchant for web development but rebuffed by JavaScript. It goes from ScalaJS basics to the implementation of a naive virtual DOM written in Scala. It presents:\n how to setup Sbt for cross compilation what is the DOM and how to manipulate it events and their propagation the Model/View/Update architecture (a.k.a the ELM architecture)  The final result can be experimented with at chrilves.github.io/slimetrail. The english material for the ScalaIO workshop are not yet available but the ones for the PSUG workshop, in french are here.\nThe Application  "
},
{
	"uri": "https://chrilves.github.io/hugo/posts/json2xml/",
	"title": "JSON to XML: the probably a tiny bit over engineered way",
	"tags": [],
	"description": "Conversion from/to JSON and XML using advanced concepts",
	"content": " The complete code of the article. You need Cats and Play-Json in order to run it.\nIt happens regularly in software development that we have to connect systems speaking different languages. JSON is nowadays ubiquitous in service communication, especially in web development but XML still has its fair amount of bastions. Imagine you need to pass information provided by a JSON API through an XML layer, you need a converter.\nThe easy way This translation is actually pretty trivial, it takes essentially 6 lines of simple pattern-matching code in Scala:\nimport play.api.libs.json._ import scala.xml._ def json2xml(json: JsValue, rootLabel: String): Elem = { // XML node creation helper  def mkElem(jsType: String, children: Node*): Elem = Elem(null, rootLabel, new UnprefixedAttribute(\u0026#34;type\u0026#34;, jsType, scala.xml.Null), TopScope, true, children: _* ) // The real translation  json match { case JsNull =\u0026gt; mkElem(\u0026#34;null\u0026#34;) case JsString(s) =\u0026gt; mkElem(\u0026#34;string\u0026#34;, PCData(s)) case JsNumber(n) =\u0026gt; mkElem(\u0026#34;number\u0026#34;, Text(n.toString)) case JsBoolean(b) =\u0026gt; mkElem(\u0026#34;boolean\u0026#34;, Text(b.toString)) case JsArray(l) =\u0026gt; mkElem(\u0026#34;array\u0026#34;, l.map(json2xml(_, s\u0026#34;${rootLabel}Item\u0026#34;)):_*) case JsObject(m) =\u0026gt; mkElem(\u0026#34;object\u0026#34;, m.toList.map { case (k,v) =\u0026gt; json2xml(v, k) }: _*) } } The trickiest part of this example is figuring out how to build XML nodes in Scala. It translates the following JSON:\n[ { \u0026#34;title\u0026#34;: \u0026#34;2001 : A Space Odyssey\u0026#34;, \u0026#34;release\u0026#34;: { \u0026#34;day\u0026#34;: 27, \u0026#34;month\u0026#34;: 9, \u0026#34;year\u0026#34;: 1968 }, \u0026#34;genres\u0026#34; : [ \u0026#34;Science fiction\u0026#34; ], \u0026#34;actors\u0026#34;: [ { \u0026#34;lastName\u0026#34;: \u0026#34;Dullea\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Keir\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;Dr. David Bowman\u0026#34; } ], \u0026#34;directors\u0026#34;: [ { \u0026#34;lastName\u0026#34;: \u0026#34;Kubrick\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Stanley\u0026#34; } ] } ] into\n\u0026lt;films type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;filmsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;title type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[2001 : A Space Odyssey]]\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;release type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;day type=\u0026#34;number\u0026#34;\u0026gt;27\u0026lt;/day\u0026gt; \u0026lt;month type=\u0026#34;number\u0026#34;\u0026gt;9\u0026lt;/month\u0026gt; \u0026lt;year type=\u0026#34;number\u0026#34;\u0026gt;1968\u0026lt;/year\u0026gt; \u0026lt;/release\u0026gt; \u0026lt;genres type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;genresItem type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Science fiction]]\u0026gt;\u0026lt;/genresItem\u0026gt; \u0026lt;/genres\u0026gt; \u0026lt;actors type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;actorsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;lastName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Dullea]]\u0026gt;\u0026lt;/lastName\u0026gt; \u0026lt;firstName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Keir]]\u0026gt;\u0026lt;/firstName\u0026gt; \u0026lt;role type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Dr. David Bowman]]\u0026gt;\u0026lt;/role\u0026gt; \u0026lt;/actorsItem\u0026gt; \u0026lt;/actors\u0026gt; \u0026lt;directors type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;directorsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;lastName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Kubrick]]\u0026gt;\u0026lt;/lastName\u0026gt; \u0026lt;firstName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Stanley]]\u0026gt;\u0026lt;/firstName\u0026gt; \u0026lt;/directorsItem\u0026gt; \u0026lt;/directors\u0026gt; \u0026lt;/filmsItem\u0026gt; \u0026lt;/films\u0026gt; Note that, unlike JSON, XML have no notion of booleans, number or null, so we add type information as attribute on each node. This has the benefit of enabling us to convert such XML back to their former JSON form. Also note that, we need CDATA sections to preserve spaces.\nProblem solved? Yes! But we can go much much further on this subject\u0026hellip;\nThe Rocket Science way There much more thing to say about this example, first let\u0026rsquo;s expose some properties of JSON values.\nInviting (Co)Algebras to the Party JSON values can be modelled with an Algebraic Data Type or ADT for short. Play-Json represents them by the type JsValue:\nsealed abstract class JsValue final case object JsNull extends JsValue final case class JsNumber(value: BigDecimal) extends JsValue final case class JsBoolean(value: Boolean) extends JsValue final case class JsString(value: String) extends JsValue final case class JsArray(value: List[JsValue]) extends JsValue final case class JsObject(value: Map[String, JsValue]) extends JsValue But in order to simplify the presentation, we will use slightly different, but equivalent, definition of JSON values:\nsealed abstract class Atomic final case object Null extends Atomic final case class Bool(value: Boolean) extends Atomic final case class Number(value: BigDecimal) extends Atomic final case class Str(value: String) extends Atomic sealed abstract class JsValue final case class JsAtom(value: Atomic) extends JsValue final case class JsArray(value: List[JsValue]) extends JsValue final case class JsObject(value: Map[String, JsValue]) extends JsValue Like in any Algebraic Data Type, the constructors of JsValues can be seen as operations on it. JsAtom informs us that every number, boolean, string and null give rise to a distinct JSON value. JsArray and JsObject tells us that each (qualified) list of JSON values forms a distinct JSON value itself. Considering that JSON values are defined in terms of these operations, and that we want to translate JSON into XML, it would make sense to define them on XML as well. First, let\u0026rsquo;s explicit these operations:\nsealed abstract class JsLike[+R] final case class Atom(value: Atomic) extends JsLike[Nothing] final case class Arr[+R](value: List[R]) extends JsLike[R] final case class Obj[+R](value: Map[String, R]) extends JsLike[R] The interesting point here is we can translate back and forth between JsValue and JsLike[JsValue]. These translations are even the inverse of each other, meaning both types are totally equivalent!\nval jsLike2JsValue: JsLike[JsValue] =\u0026gt; JsValue = { case Atom(a) =\u0026gt; JsAtom(a) case Arr(a) =\u0026gt; JsArray(a) case Obj(m) =\u0026gt; JsObject(m) } val jsValue2JsLike: JsValue =\u0026gt; JsLike[JsValue] = { case JsAtom(a) =\u0026gt; Atom(a) case JsArray(a) =\u0026gt; Arr(a.toList) case JsObject(m) =\u0026gt; Obj(m) } jsLike2JsValue is called a JsLike-Algebra because it has the form JsLike[X] =\u0026gt; X. It means jsLike2JsValue is a way \u0026ldquo;compute\u0026rdquo; JsLike operation, i.e. it composes values to form new ones. On the opposite, jsValue2JsLike is called a JsLike-CoAlgebra because it has the form X =\u0026gt; JsLike[X]. It is a way to expose how a value is built, i.e. it deconstructs values to expose their structure.\nCan we find such functions for XML values? We are looking for two functions:\nval jsLike2Elem: JsLike[Elem] =\u0026gt; Elem = ??? val elem2JsLike: Elem =\u0026gt; JsLike[Elem] = ??? It would certainly be nice, but unfortunately this is not that simple! 5, true and null are valid JSON values, So jsLike2Elem(Atom(Number(5))), jsLike2Elem(Atom(Bool(true))) and jsLike2Elem(Atom(Null))) should be valid XML value! But what should be the root tag of the resulting elements? How to translate 5 into a valid XML? We know that it would have the form:\n\u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; But what someRootTag should be? We could pick an arbitrary one, but it would break composability (try it, you\u0026rsquo;ll see!). There\u0026rsquo;s no escape, all XML values need tags but not every JSON value have some! The situation suggest JSON values are closer to \u0026ldquo;XML values with unknown root tags\u0026rdquo; \u0026lt;X type=\u0026quot;number\u0026quot;\u0026gt;5\u0026lt;/X\u0026gt; where X as the unknown, i.e. the functional space String =\u0026gt; Elem:\nval _5: String =\u0026gt; Elem = (someRootTag: String) =\u0026gt; \u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; Do you think we can define meaningful functions?\nval jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) = ??? val xml2JsLike: (String =\u0026gt; Elem) =\u0026gt; JsLike[String =\u0026gt; Elem] = ??? Yes we can \u0026hellip; partially. We can define jsLike2xml:\nval jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) = { def mkRoot(jsType: String, children: Node*): String =\u0026gt; Elem = (someRootTag: String) =\u0026gt; Elem(null, someRootTag, new UnprefixedAttribute(\u0026#34;type\u0026#34;, jsType, scala.xml.Null), TopScope, true, children: _* ) (j: JsLike[String =\u0026gt; Elem]) =\u0026gt; j match { case Atom(Null) =\u0026gt; mkRoot(\u0026#34;null\u0026#34;) case Atom(Str(s)) =\u0026gt; mkRoot(\u0026#34;string\u0026#34;, PCData(s)) case Atom(Bool(b)) =\u0026gt; mkRoot(\u0026#34;boolean\u0026#34;, Text(b.toString)) case Atom(Number(n)) =\u0026gt; mkRoot(\u0026#34;number\u0026#34;, Text(n.toString)) case Arr(a) =\u0026gt; (root: String) =\u0026gt; { mkRoot(\u0026#34;array\u0026#34;, a.map(_(s\u0026#34;${root}Item\u0026#34;)): _*)(root) } case Obj(m) =\u0026gt; mkRoot(\u0026#34;object\u0026#34;, m.toList.map { case (k, v) =\u0026gt; v(k) }: _*) } } but for xml2JsLike, we\u0026rsquo;re facing two not-that-small issues:\n First, unlikejsValue2JsLike, we can not pattern-match on functions. We have no sane way to know that  (someRootTag: String) =\u0026gt; \u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; is built from Atom(Number(5)).\n Even if we could pattern-match on functions, jsLike2xml is not surjective, i.e. not every XML element is the result of jsLike2xml(f) for some f. To deal with invalid input, the return type of xml2JsLike can not be JsLike[String =\u0026gt; Elem] but F[JsLike[String =\u0026gt; Elem]] for some functor F able to deal with errors like Option, Either, etc. For simplicity\u0026rsquo;s sake, let\u0026rsquo;s consider F to be Option.  Let\u0026rsquo;s once again take a step back. We want to decompose a function (f: String =\u0026gt; Elem) into an Option[JsLike[String =\u0026gt; Elem]] without pattern-matching it. The only reasonable thing we can do with functions is pass them some arguments:\ndef xml2JsLike(f: (String =\u0026gt; Elem)): String =\u0026gt; Option[JsLike[Elem =\u0026gt; String]] = (someRootTag: String) =\u0026gt; ... f(someRootTag) ... The type String =\u0026gt; Option[A] is actually a monad, known as a ReaderT[Option, String, A]. Which makes xml2JsLike a monadic coalgebra. Let\u0026rsquo;s give it a name:\nimport cats.data.ReaderT type TagOpt[A] = ReaderT[Option, String, A] As an exercise try to implement xml2JsLike. *To that end, it may be useful to notice that JsLike is a Traverse, i.e. that an instance of Traverse[JsLike] can be defined. Such an instance defines a function:\ndef `traverse[G[_]: Applicative, A, B](ja: JsLike[A])(f: A =\u0026gt; G[B]): G[JsLike[B]]` To summarize this part, we have these four functions:\nval jsLike2JsValue: JsLike[JsValue] =\u0026gt; JsValue val jsValue2JsLike: JsValue =\u0026gt; JsLike[JsValue] val jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) val xml2JsLike: (String =\u0026gt; Elem) =\u0026gt; TagOpt[JsLike[String =\u0026gt; Elem]] Now we want to convert JsValue from/into String =\u0026gt; Elem.\nConverting back and forth Now that we know how to compose and decompose both JSON and XML values. How do we write converters? For simplify\u0026rsquo;s sake, let\u0026rsquo;s be a bit more abstract. Let A and B be to types (like JsValue and String =\u0026gt; Elem) and F[_] a type constructor (like JsLike) that have the nice property of being a functor (i.e. it has function map: F[A] =\u0026gt; (A =\u0026gt; B) =\u0026gt; F[B]). In addition, let decomposeA: A =\u0026gt; F[A] and recomposeB: F[B] =\u0026gt; B (like jsValue2JsLike and jsLike2xml). We want a function convert: A =\u0026gt; B:\ntrait Direct { import cats.Functor import cats.syntax.functor._ type A type B type F[_] implicit val fHasMap: Functor[F] val decomposeA: A =\u0026gt; F[A] val recomposeB: F[B] =\u0026gt; B final def convert(a: A): B = { val fa: F[A] = decomposeA(a) val fb: F[B] = fa.map(convert) recomposeB(fb): B } } Or in a more compact way:\ndef hylo[A,B, F[_]: Functor](decompose: A =\u0026gt; F[A], recompose: F[B] =\u0026gt; B): A =\u0026gt; B = { def convert(a: A): B = recompose(decompose(a).map(convert)) convert _ } And voila, a converter in just 1 lines of code:\ndef json2xml(json: JsValue): String =\u0026gt; Elem = hylo(jsValue2JsLike, jsLike2xml).apply(json) The way back is only a bit more involving. This time we require F to be Traverse and the function decomposeA to be of type A =\u0026gt; M[F[A]] for some monad M:\ntrait WayBack { type A type B type F[_] implicit val fHasTraverse: Traverse[F] type M[_] implicit val mIsAMonad: Monad[M] val decomposeA: A =\u0026gt; M[F[A]] val recomposeB: F[B] =\u0026gt; B final def convert(a: A): M[B] = for { fa \u0026lt;- decomposeA(a) fb \u0026lt;- fa.traverse(convert) } yield recomposeB(fb) } Again, in a more compact way:\ndef hyloish[A,B, F[_]: Traverse, M[_]: Monad](decompose: A =\u0026gt; M[F[A]], recompose: F[B] =\u0026gt; B): A =\u0026gt; M[B] = { def convert(a: A): M[B] = for { fa \u0026lt;- decompose(a) fb \u0026lt;- fa.traverse(convert) } yield recompose(fb) convert _ } which gives the way back as the oneliner:\ndef xml2json(f: String =\u0026gt; Elem): TagOpt[JsValue] = hyloish(xml2JsLike, jsLike2JsValue).apply(f) Reorganizing a bit, it leads to the two conversion functions between (String, JsValue) and Elem:\nval json2xmlBetter: ((String, JsValue)) =\u0026gt; Elem = (jsonPlusTag: (String, JsValue)) =\u0026gt; json2xml(jsonPlusTag._2)(jsonPlusTag._1) val xml2jsonBetter: Elem =\u0026gt; TagOpt[(String, JsValue)] = (e: Elem) =\u0026gt; xml2json((s: String) =\u0026gt; e.copy(label = s)).map(e.label -\u0026gt; _) What\u0026rsquo;s the point? Apart from being so much more complicated that the trivial approach, is there some benefits? Actually yes.\n Firstly, given n formats, there are n² converters. Writing and testing n² functions is a lot of tedious and error-prone work. But if you find some common operations F[_], you only need 2n functions (one X =\u0026gt; F[X] and one F[X] =\u0026gt; X for each format X) to achieve the same goal. Furthermore, each of those functions will be easier to test, which is not to neglect. Secondly, algebras (functions X =\u0026gt; F[X]) and coalgebras (functions F[X] =\u0026gt; X) operate one level at a time. They enable to treat format X as if it was an algebraic data type over operations F. Pattern-matching is such a nice feature! Thirdly, you can write generic functions taking any type X for which you can provide functions X =\u0026gt; F[X] and F[X] =\u0026gt; X. These functions also have higher chances of being correct because there is less space for unexpected behaviour.  If want to dive deeper in this subject, you can look at Matryoshka, read Functional programming with bananas, lenses, envelopes and barbed wire or any resource on F-Algebras and recursion schemes.\nSolution to exercises JsLike instance for Traverse implicit val jsLikeInstances: Traverse[JsLike] = new Traverse[JsLike] { import cats.Eval def traverse[G[_], A, B](fa: JsLike[A])(f: A =\u0026gt; G[B])( implicit G: Applicative[G]): G[JsLike[B]] = fa match { case Atom(a) =\u0026gt; G.point(Atom(a)) case Arr(a) =\u0026gt; a.traverse[G, B](f).map(Arr(_)) case Obj(m) =\u0026gt; m.toList .traverse[G, (String, B)] { case (s, a) =\u0026gt; f(a).map(s -\u0026gt; _) } .map(i =\u0026gt; Obj(i.toMap)) } def foldLeft[A, B](fa: JsLike[A], b: B)(f: (B, A) =\u0026gt; B): B = fa match { case Atom(_) =\u0026gt; b case Arr(a) =\u0026gt; a.foldLeft(b)(f) case Obj(m) =\u0026gt; m.values.foldLeft(b)(f) } def foldRight[A, B](fa: JsLike[A], lb: Eval[B])( f: (A, Eval[B]) =\u0026gt; Eval[B]): Eval[B] = fa match { case Atom(_) =\u0026gt; lb case Arr(a) =\u0026gt; a.foldRight(lb)(f) case Obj(m) =\u0026gt; m.values.foldRight(lb)(f) } } xml2JsLike def xml2JsLike(f: String =\u0026gt; Elem): TagOpt[JsLike[String =\u0026gt; Elem]] = ReaderT[Option, String, JsLike[String =\u0026gt; Elem]] { (s: String) =\u0026gt; val elem: Elem = f(s) elem .attributes .asAttrMap .get(\u0026#34;type\u0026#34;) .flatMap[JsLike[String =\u0026gt; Elem]] { case \u0026#34;null\u0026#34; =\u0026gt; Some(Atom(Null)) case \u0026#34;boolean\u0026#34; =\u0026gt; elem.text match { case \u0026#34;true\u0026#34; =\u0026gt; Some(Atom(Bool(true))) case \u0026#34;false\u0026#34; =\u0026gt; Some(Atom(Bool(false))) case _ =\u0026gt; None } case \u0026#34;number\u0026#34; =\u0026gt; import scala.util.Try Try(BigDecimal(elem.text)) .toOption .map(n =\u0026gt; Atom(Number(n))) case \u0026#34;string\u0026#34; =\u0026gt; Some(Atom(Str(elem.text))) case \u0026#34;array\u0026#34; =\u0026gt; Some(Arr( elem .child .toList .flatMap { case e: Elem =\u0026gt; List((s: String) =\u0026gt; e.copy(label = s)) case _ =\u0026gt; Nil } )) case \u0026#34;object\u0026#34; =\u0026gt; Some(Obj( elem .child .toList .flatMap { case e: Elem =\u0026gt; List(e.label -\u0026gt; ((s: String) =\u0026gt; e.copy(label = s))) case _ =\u0026gt; Nil }.toMap )) case _ =\u0026gt; None } }"
},
{
	"uri": "https://chrilves.github.io/hugo/posts/falgebra_scalaio_2017/",
	"title": "F-Algebra talk at ScalaIO 2017: Modéliser astucieusement vos données",
	"tags": [],
	"description": "ScalaIO.2017 Talk",
	"content": " I had the chance to present a talk about F-Algebras at ScalaIO 2017.\nThe Video  The Slides  "
},
{
	"uri": "https://chrilves.github.io/hugo/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " @chrilves\u0026rsquo; Archives "
},
{
	"uri": "https://chrilves.github.io/hugo/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://chrilves.github.io/hugo/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]