[
{
	"uri": "/hugo/posts/folds/",
	"title": "Let&#39;s meet the charming fold family",
	"tags": [],
	"description": "",
	"content": " Today we will meet an amazing family: the fold functions!\nThe well known foldRight Lists is one of the first data structure every developer/computer scientist meet in her/his journey into programming:\nsealed abstract class List[+A] final case object Nil extends List[Nothing] final case class Cons[+A](head: A, tail: List[A]) extends List[A] It means means values of type List[A] can be of (only) two forms:\n either Nil or Cons(head, tail) for some values head of type A and tail of type List[A]  For example we can define the following lists:\nval empty : List[Int] = Nil val l1 : List[Int] = Cons(61, Nil) val l2 : List[Int] = Cons(34, Cons(61, Nil)) val l3 : List[String] = Cons(\u0026#34;a\u0026#34;, Cons(\u0026#34;b\u0026#34;, Cons(\u0026#34;c\u0026#34;, Nil))) In addition, Nil and Cons can be seen as constants and functions returning List[A]:\ndef nil[A]: List[A] = Nil def cons[A](head: A, tail: List[A]): Lis[A] = Cons(head, tail) The fold function, often called foldRight, answers the question:\n What would have happened if, instead of having used Nil and Cons in the construction of a list l:List[A], we would have used another constant z:T and another function f:(A, T) =\u0026gt; T for some type T?\n Let\u0026rsquo;s illustrate this using the previous examples:\nval empty : Int = 0 // z = 0 val v1 : Int = max(61, 0) // z = 0, f = max val v2 : Int = mult(34, mult(61, 1)) // z = 1, f = mult val v3 : String = concat(\u0026#34;a\u0026#34;, concat(\u0026#34;b\u0026#34;, concat(\u0026#34;c\u0026#34;, \u0026#34;\u0026#34;))) -- z = \u0026#34;\u0026#34;, f = concat The definition of foldRight illustrates well the transformation process. It deconstructs the list l:List[A] and replace Nil by z and Cons by f:\ndef foldList[A,T](z: T, f: (A,T) =\u0026gt; T): List[A] =\u0026gt; T = { def transform(l: List[A]): T = l match { case Nil =\u0026gt; z case Cons(head, tail) =\u0026gt; val transformedTail = transform(tail) f(head, transformedTail) } transform _ } The simple cases: Enum Types fold functions can be defined for a wide range of data structures. As a first example, let\u0026rsquo;s take this type:\nsealed abstract class SingletonType final case object SingleValue extends SingletonType The type SingletonType admits one and only one value: SingleValue. Folding over SingletonType means, replacing SingleValue by a constant z:T for some type T :\ndef foldSingletonType[T](z:T): SingletonType =\u0026gt; T = { def transform(v: SingletonType): T = v match { case SingleValue =\u0026gt; z } transform _ } While SingletonType has only one value, the type Boolean have exactly two values True and False:\nsealed abstract class Boolean final case object True extends Boolean final case object False extends Boolean So folding over Booleans mean, given a type T and two constants tt:T and ff:T, replacing True by tt and False by ff:\ndef foldBoolean[T](tt:T, ff:T): Boolean =\u0026gt; T = { def transform(v: Boolean): T = v match { case True =\u0026gt; tt case False =\u0026gt; ff } transform _ } And so on for every enum type.\nBeyond enums You may start the see general process. If values of type C are build using constructors (Nil and Cons[A] for List[A], SingleValue for SingletonType, True and False for Boolean), then folding is all about transforming values of type C into another type T by replacing each constructor of C by a constant or function on T of the same shape. Let\u0026rsquo;s consider the type Either[A,B]:\nsealed abstract class Either[A,B] final case class Left[A,B](value: A) extends Either[A,B] final case class Right[A,B](value: B) extends Either[A,B] To transform values of type Either[A,B] into T we need two functions on T:\n Left being of type A =\u0026gt; Either[A,B] we need a function f: A =\u0026gt; T. Right being of type B =\u0026gt; Either[A,B] we need a function g: B =\u0026gt; T.  Then we can operate the transformation:\ndef foldEither[A,B,T](f: A =\u0026gt; T, g: B =\u0026gt; T): Either[A,B] =\u0026gt; T = { def transform(v: Either[A,B]): T = v match { case Left(a) =\u0026gt; f(a) case Right(b) =\u0026gt; g(b) } transform _ } Recursive Types Folding over recursive types obey the previous rules. Recursion is handled by transforming sub-terms first. Let\u0026rsquo;s consider the type of binary trees:\nsealed abstract class Tree[+A] final case object Empty extends Tree[Nothing] final case class Node[+A](value:A, left: Tree[A], right: Tree[A]) extends Tree[A] To transform values of type Tree[A] into T we need:\n Empty being a constant of type Tree[A], we need a constant z:T. Node being a function of type (A, Tree[A], Tree[A]) =\u0026gt; Tree[A] we need a function f: (A, T, T) =\u0026gt; T. Note how all occurrences of Tree[A] have been replaced by T in the type.  Then we can operate the transformation:\ndef foldTree[A,T](z: T, f: (A, T, T) =\u0026gt; T): Tree[A] =\u0026gt; T = { def transform(v: Tree[A]): T = v match { case Empty =\u0026gt; z case Node(a,l,r) =\u0026gt; val g: T = transform(l) // Transforming sub-term l  val d: T = transform(r) // Transforming sub-term r  f(a,g,d) } transform _ } Generalized Algebraic Data Types (GADT) Instead of giving a formal definition of what Generalized Algebraic Data Types i will show you some examples.\nType Equalities Consider the type:\nsealed abstract class EmptyOrSingleton[A] final case object SingleValueIfAisInt extends EmptyOrSingleton[Int] This type looks very similar to SingletonType but, while SingleValue was always a value of SingletonType, SingleValueIfAisInt is only a value of EmptyOrSingleton[Int], i.e. when A is Int. So what happens to EmptyOrSingleton[A] when A is not Int? Then there is no constructor for EmptyOrSingleton[A] so no value for SingletonIfInt[A] (excluding null which we will pretend no to exist).\nGADTs are very useful to encode predicates over types. Imagine you have a value v:EmptyOrSingleton[A] for some type A (remember we pretend null does not exist). What could you say about A? The only way to get a value of type EmptyOrSingleton[A] is through SingleValueIfAisInt. Thus v is SingleValueIfAisInt which is of type EmptyOrSingleton[Int] so is v. We can conclude that A is actually Int. Not convinced? Let A be String, can you build a value of type EmptyOrSingleton[String] without using null? Try it.\nTo find how to fold EmptyOrSingleton[A] into T, let\u0026rsquo;s apply the technique we used in the previous sections. EmptyOrSingleton[A] has only one constructor, SingleValueIfAisInt, so we need a constant z:T. But SingleValueIfAisInt is not of type EmptyOrSingleton[A] but EmptyOrSingleton[Int]. The argument A matters so let T depend on A: we want to transform values of type EmptyOrSingleton[A] into T[A].\n SingleValueIfAisInt being of type EmptyOrSingleton[Int] we need a constant z:T[Int]  Then we can operate the transformation:\ndef foldEmptyOrSingleton[A, T[_]](z: T[Int]): EmptyOrSingleton[A] =\u0026gt; T[A] = { def transform(v: EmptyOrSingleton[A]): T[A] = v match { case SingleValueIfAisInt =\u0026gt; z // Because we know A = Int  } transform _ } foldEmptyOrSingleton means that, for some T[_], if you have a value z:T[Int] then you can transform any value EmptyOrSingleton[A] into T[A]. For example, let\u0026rsquo;s take\ntype T[X] = X =:= Int val z:T[Int] = implicitly[Int =:= Int] Then foldEmptyOrSingleton[A,T](z) gives us, for any value v:EmptyOrSingleton[A] a proof that A =:= Int. Another important use case is asserting type equality:\nsealed abstract class Eq[A,B] final case class Refl[X]() extends Eq[X,X] Any non-null value v:Eq[A,B] must be a Refl[X]() : Eq[X,X] for some X, then Eq[A,B] = Eq[X,X] proving that A = X = B. To transform a value of type Eq[A,B] into T[A,B] we need:\n Refl[X]() is essentially a constant of type Eq[X,X] for all type X (note: Scala write this type [X]Eq[X,X]). We need a constant z:T[X,X] for all type X (so the type [X]T[X,X]). Scala does not support transparent higher-ranked types, we need to emulate them with a trait:  trait ElimRefl[T[_,_]] { def apply[X]: T[X,X] } Then we could have hoped to be able to operate the transformation like previous section. But given a value v:Eq[A,B], convincing Scala that A = B is a bit tough. Instead we can write the fold as a method:\nsealed abstract class Eq[A,B] { def fold[T[_,_]](z: ElimRefl[T]): T[A,B] } final case class Refl[X]() extends Eq[X,X] { def fold[T[_,_]](z: ElimRefl[T]): T[X,X] = z[X] } def foldEq[A, B, T[_,_]](z: ElimRefl[T]): Eq[A,B] =\u0026gt; T[A,B] = (v:Eq[A,B]) =\u0026gt; v.fold[T](z) Ingenious definition of T[_,_] leads to interesting results:\ntrait C[X] type T1[A,B] = C[A] =:= C[B] val z1: ElimRefl[T1] = new ElimRefl[T1] { def apply[X]: T1[X,X] = implicitly[C[X] =:= C[X]] } def transform[A,B]: Eq[A,B] =\u0026gt; C[A] =:= C[B] = foldEq[A,B,T1](z1) Existential Quantification GADTs not only provide useful type equalities, they also offer existential quantification!\nsealed abstract class Ex[F[_]] { type hidden val value: hidden val evidence: F[hidden] } final case class MakeEx[F[_],A](value: A, evidence: F[A]) extends Ex[F] { type hidden = A } Any value v:Ex[F] has to be an instance of MakeEx[F,A] for some type A. Which means we have a value, v.value, of type A and an instance of the type-class F for A (for example an instance of Monoid[A] with F[X] = Monoid[X]).\nTo transform values of type Ex[F] into T we need:\n MakeEx[F[_],?] being of type [A](A, F[A]) =\u0026gt; Ex[F] meaning: For_all_type A, (A, F[A]) =\u0026gt; Ex[F], we need a function f of type [A](A, F[A]) =\u0026gt; T. Scala still does not support transparent higher ranked types, we need to emulate them with another trait:  trait ElimMakeEx[F[_],T] { def apply[A](value: A, evidence: F[A]): T } Then we can operate the transformation:\ndef foldEx[F[_], T](f: ElimMakeEx[F, T]): Ex[F] =\u0026gt; T = { def transform(v: Ex[F]): T = v match { case w@MakeEx(value, evidence) =\u0026gt; f[w.hidden](value, evidence) } transform _ } Duality In this post we have deduced the fold functions from the definition of each type. It is possible to do the opposite: each constructor can be derived from the fold function of its type. For example:\ntrait List[+A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T } def nil[A]: List[A] = new List[A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T = z } def cons[A](head:A, tail: List[A]): List[A] = new List[A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T = f(head, tail.fold(z,f)) } def equality[A](l1: List[A], l2:List[A]): Boolean = ??? // Difficult but worthy exercice Conclusion I hope i convinced you folds are immensely useful. First, they let us write simply complex transform functions. But this not the most interesting property. It is sometimes easier to define a type by its fold function. Java, for example, does not have support for neither sealed classes nor pattern-matching. How could we define the List type so that Nil and Cons are the two only cases? The fold function forces any instance of List to fit into the desired shape (if some rules are obeyed like no null and no runtime-reflection). It can also happen that type-inference is not smart enough, fold function provide an alternative way which is often easier for the Scala type-checker.\n"
},
{
	"uri": "/hugo/posts/slimetrail/",
	"title": "How to make game in the browser thanks to ScalaJS",
	"tags": [],
	"description": "",
	"content": "A few month ago, the Paris Scala User Group kindly invited me present a workshop introducing [Scala.js(https://www.scala-js.org/). Even better, i will have the chance to present it in october at ScalaIO.\nI will present how to develop a web application in Scala.js. This talk is for Scala developers having a penchant for web development but rebuffed by JavaScript. It goes from ScalaJS basics to the implementation of a naive virtual DOM written in Scala. It presents:\n how to setup Sbt for cross compilation what is the DOM and how to manipulate it events and their propagation the Model/View/Update architecture (a.k.a the ELM architecture)  The final result can be experimented with at chrilves.github.io/slimetrail. The english material for the ScalaIO workshop are not yet available but the ones for the PSUG workshop, in french are here.\n"
},
{
	"uri": "/hugo/posts/json2xml/",
	"title": "JSON to XML: the probably a tiny bit over engineered way",
	"tags": [],
	"description": "",
	"content": " The complete code of the article. You need Cats and Play-Json in order to run it.\nIt happens regularly in software development that we have to connect systems speaking different languages. JSON is nowadays ubiquitous in service communication, especially in web development but XML still has its fair amount of bastions. Imagine you need to pass information provided by a JSON API through an XML layer, you need a converter.\nThe easy way This translation is actually pretty trivial, it takes essentially 6 lines of simple pattern-matching code in Scala:\nimport play.api.libs.json._ import scala.xml._ def json2xml(json: JsValue, rootLabel: String): Elem = { // XML node creation helper  def mkElem(jsType: String, children: Node*): Elem = Elem(null, rootLabel, new UnprefixedAttribute(\u0026#34;type\u0026#34;, jsType, scala.xml.Null), TopScope, true, children: _* ) // The real translation  json match { case JsNull =\u0026gt; mkElem(\u0026#34;null\u0026#34;) case JsString(s) =\u0026gt; mkElem(\u0026#34;string\u0026#34;, PCData(s)) case JsNumber(n) =\u0026gt; mkElem(\u0026#34;number\u0026#34;, Text(n.toString)) case JsBoolean(b) =\u0026gt; mkElem(\u0026#34;boolean\u0026#34;, Text(b.toString)) case JsArray(l) =\u0026gt; mkElem(\u0026#34;array\u0026#34;, l.map(json2xml(_, s\u0026#34;${rootLabel}Item\u0026#34;)):_*) case JsObject(m) =\u0026gt; mkElem(\u0026#34;object\u0026#34;, m.toList.map { case (k,v) =\u0026gt; json2xml(v, k) }: _*) } } The trickiest part of this example is figuring out how to build XML nodes in Scala. It translates the following JSON:\n[ { \u0026#34;title\u0026#34;: \u0026#34;2001 : A Space Odyssey\u0026#34;, \u0026#34;release\u0026#34;: { \u0026#34;day\u0026#34;: 27, \u0026#34;month\u0026#34;: 9, \u0026#34;year\u0026#34;: 1968 }, \u0026#34;genres\u0026#34; : [ \u0026#34;Science fiction\u0026#34; ], \u0026#34;actors\u0026#34;: [ { \u0026#34;lastName\u0026#34;: \u0026#34;Dullea\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Keir\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;Dr. David Bowman\u0026#34; } ], \u0026#34;directors\u0026#34;: [ { \u0026#34;lastName\u0026#34;: \u0026#34;Kubrick\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Stanley\u0026#34; } ] } ] into\n\u0026lt;films type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;filmsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;title type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[2001 : A Space Odyssey]]\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;release type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;day type=\u0026#34;number\u0026#34;\u0026gt;27\u0026lt;/day\u0026gt; \u0026lt;month type=\u0026#34;number\u0026#34;\u0026gt;9\u0026lt;/month\u0026gt; \u0026lt;year type=\u0026#34;number\u0026#34;\u0026gt;1968\u0026lt;/year\u0026gt; \u0026lt;/release\u0026gt; \u0026lt;genres type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;genresItem type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Science fiction]]\u0026gt;\u0026lt;/genresItem\u0026gt; \u0026lt;/genres\u0026gt; \u0026lt;actors type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;actorsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;lastName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Dullea]]\u0026gt;\u0026lt;/lastName\u0026gt; \u0026lt;firstName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Keir]]\u0026gt;\u0026lt;/firstName\u0026gt; \u0026lt;role type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Dr. David Bowman]]\u0026gt;\u0026lt;/role\u0026gt; \u0026lt;/actorsItem\u0026gt; \u0026lt;/actors\u0026gt; \u0026lt;directors type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;directorsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;lastName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Kubrick]]\u0026gt;\u0026lt;/lastName\u0026gt; \u0026lt;firstName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Stanley]]\u0026gt;\u0026lt;/firstName\u0026gt; \u0026lt;/directorsItem\u0026gt; \u0026lt;/directors\u0026gt; \u0026lt;/filmsItem\u0026gt; \u0026lt;/films\u0026gt; Note that, unlike JSON, XML have no notion of booleans, number or null, so we add type information as attribute on each node. This has the benefit of enabling us to convert such XML back to their former JSON form. Also note that, we need CDATA sections to preserve spaces.\nProblem solved? Yes! But we can go much much further on this subject\u0026hellip;\nThe Rocket Science way There much more thing to say about this example, first let\u0026rsquo;s expose some properties of JSON values.\nInviting (Co)Algebras to the Party JSON values can be modelled with an Algebraic Data Type or ADT for short. Play-Json represents them by the type JsValue:\nsealed abstract class JsValue final case object JsNull extends JsValue final case class JsNumber(value: BigDecimal) extends JsValue final case class JsBoolean(value: Boolean) extends JsValue final case class JsString(value: String) extends JsValue final case class JsArray(value: List[JsValue]) extends JsValue final case class JsObject(value: Map[String, JsValue]) extends JsValue But in order to simplify the presentation, we will use slightly different, but equivalent, definition of JSON values:\nsealed abstract class Atomic final case object Null extends Atomic final case class Bool(value: Boolean) extends Atomic final case class Number(value: BigDecimal) extends Atomic final case class Str(value: String) extends Atomic sealed abstract class JsValue final case class JsAtom(value: Atomic) extends JsValue final case class JsArray(value: List[JsValue]) extends JsValue final case class JsObject(value: Map[String, JsValue]) extends JsValue Like in any Algebraic Data Type, the constructors of JsValues can be seen as operations on it. JsAtom informs us that every number, boolean, string and null give rise to a distinct JSON value. JsArray and JsObject tells us that each (qualified) list of JSON values forms a distinct JSON value itself. Considering that JSON values are defined in terms of these operations, and that we want to translate JSON into XML, it would make sense to define them on XML as well. First, let\u0026rsquo;s explicit these operations:\nsealed abstract class JsLike[+R] final case class Atom(value: Atomic) extends JsLike[Nothing] final case class Arr[+R](value: List[R]) extends JsLike[R] final case class Obj[+R](value: Map[String, R]) extends JsLike[R] The interesting point here is we can translate back and forth between JsValue and JsLike[JsValue]. These translations are even the inverse of each other, meaning both types are totally equivalent!\nval jsLike2JsValue: JsLike[JsValue] =\u0026gt; JsValue = { case Atom(a) =\u0026gt; JsAtom(a) case Arr(a) =\u0026gt; JsArray(a) case Obj(m) =\u0026gt; JsObject(m) } val jsValue2JsLike: JsValue =\u0026gt; JsLike[JsValue] = { case JsAtom(a) =\u0026gt; Atom(a) case JsArray(a) =\u0026gt; Arr(a.toList) case JsObject(m) =\u0026gt; Obj(m) } jsLike2JsValue is called a JsLike-Algebra because it has the form JsLike[X] =\u0026gt; X. It means jsLike2JsValue is a way \u0026ldquo;compute\u0026rdquo; JsLike operation, i.e. it composes values to form new ones. On the opposite, jsValue2JsLike is called a JsLike-CoAlgebra because it has the form X =\u0026gt; JsLike[X]. It is a way to expose how a value is built, i.e. it deconstructs values to expose their structure.\nCan we find such functions for XML values? We are looking for two functions:\nval jsLike2Elem: JsLike[Elem] =\u0026gt; Elem = ??? val elem2JsLike: Elem =\u0026gt; JsLike[Elem] = ??? It would certainly be nice, but unfortunately this is not that simple! 5, true and null are valid JSON values, So jsLike2Elem(Atom(Number(5))), jsLike2Elem(Atom(Bool(true))) and jsLike2Elem(Atom(Null))) should be valid XML value! But what should be the root tag of the resulting elements? How to translate 5 into a valid XML? We know that it would have the form:\n\u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; But what someRootTag should be? We could pick an arbitrary one, but it would break composability (try it, you\u0026rsquo;ll see!). There\u0026rsquo;s no escape, all XML values need tags but not every JSON value have some! The situation suggest JSON values are closer to \u0026ldquo;XML values with unknown root tags\u0026rdquo; \u0026lt;X type=\u0026quot;number\u0026quot;\u0026gt;5\u0026lt;/X\u0026gt; where X as the unknown, i.e. the functional space String =\u0026gt; Elem:\nval _5: String =\u0026gt; Elem = (someRootTag: String) =\u0026gt; \u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; Do you think we can define meaningful functions?\nval jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) = ??? val xml2JsLike: (String =\u0026gt; Elem) =\u0026gt; JsLike[String =\u0026gt; Elem] = ??? Yes we can \u0026hellip; partially. We can define jsLike2xml:\nval jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) = { def mkRoot(jsType: String, children: Node*): String =\u0026gt; Elem = (someRootTag: String) =\u0026gt; Elem(null, someRootTag, new UnprefixedAttribute(\u0026#34;type\u0026#34;, jsType, scala.xml.Null), TopScope, true, children: _* ) (j: JsLike[String =\u0026gt; Elem]) =\u0026gt; j match { case Atom(Null) =\u0026gt; mkRoot(\u0026#34;null\u0026#34;) case Atom(Str(s)) =\u0026gt; mkRoot(\u0026#34;string\u0026#34;, PCData(s)) case Atom(Bool(b)) =\u0026gt; mkRoot(\u0026#34;boolean\u0026#34;, Text(b.toString)) case Atom(Number(n)) =\u0026gt; mkRoot(\u0026#34;number\u0026#34;, Text(n.toString)) case Arr(a) =\u0026gt; (root: String) =\u0026gt; { mkRoot(\u0026#34;array\u0026#34;, a.map(_(s\u0026#34;${root}Item\u0026#34;)): _*)(root) } case Obj(m) =\u0026gt; mkRoot(\u0026#34;object\u0026#34;, m.toList.map { case (k, v) =\u0026gt; v(k) }: _*) } } but for xml2JsLike, we\u0026rsquo;re facing two not-that-small issues:\n First, unlikejsValue2JsLike, we can not pattern-match on functions. We have no sane way to know that  (someRootTag: String) =\u0026gt; \u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; is built from Atom(Number(5)).\n Even if we could pattern-match on functions, jsLike2xml is not surjective, i.e. not every XML element is the result of jsLike2xml(f) for some f. To deal with invalid input, the return type of xml2JsLike can not be JsLike[String =\u0026gt; Elem] but F[JsLike[String =\u0026gt; Elem]] for some functor F able to deal with errors like Option, Either, etc. For simplicity\u0026rsquo;s sake, let\u0026rsquo;s consider F to be Option.  Let\u0026rsquo;s once again take a step back. We want to decompose a function (f: String =\u0026gt; Elem) into an Option[JsLike[String =\u0026gt; Elem]] without pattern-matching it. The only reasonable thing we can do with functions is pass them some arguments:\ndef xml2JsLike(f: (String =\u0026gt; Elem)): String =\u0026gt; Option[JsLike[Elem =\u0026gt; String]] = (someRootTag: String) =\u0026gt; ... f(someRootTag) ... The type String =\u0026gt; Option[A] is actually a monad, known as a ReaderT[Option, String, A]. Which makes xml2JsLike a monadic coalgebra. Let\u0026rsquo;s give it a name:\nimport cats.data.ReaderT type TagOpt[A] = ReaderT[Option, String, A] As an exercise try to implement xml2JsLike. *To that end, it may be useful to notice that JsLike is a Traverse, i.e. that an instance of Traverse[JsLike] can be defined. Such an instance defines a function:\ndef `traverse[G[_]: Applicative, A, B](ja: JsLike[A])(f: A =\u0026gt; G[B]): G[JsLike[B]]` To summarize this part, we have these four functions:\nval jsLike2JsValue: JsLike[JsValue] =\u0026gt; JsValue val jsValue2JsLike: JsValue =\u0026gt; JsLike[JsValue] val jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) val xml2JsLike: (String =\u0026gt; Elem) =\u0026gt; TagOpt[JsLike[String =\u0026gt; Elem]] Now we want to convert JsValue from/into String =\u0026gt; Elem.\nConverting back and forth Now that we know how to compose and decompose both JSON and XML values. How do we write converters? For simplify\u0026rsquo;s sake, let\u0026rsquo;s be a bit more abstract. Let A and B be to types (like JsValue and String =\u0026gt; Elem) and F[_] a type constructor (like JsLike) that have the nice property of being a functor (i.e. it has function map: F[A] =\u0026gt; (A =\u0026gt; B) =\u0026gt; F[B]). In addition, let decomposeA: A =\u0026gt; F[A] and recomposeB: F[B] =\u0026gt; B (like jsValue2JsLike and jsLike2xml). We want a function convert: A =\u0026gt; B:\ntrait Direct { import cats.Functor import cats.syntax.functor._ type A type B type F[_] implicit val fHasMap: Functor[F] val decomposeA: A =\u0026gt; F[A] val recomposeB: F[B] =\u0026gt; B final def convert(a: A): B = { val fa: F[A] = decomposeA(a) val fb: F[B] = fa.map(convert) recomposeB(fb): B } } Or in a more compact way:\ndef hylo[A,B, F[_]: Functor](decompose: A =\u0026gt; F[A], recompose: F[B] =\u0026gt; B): A =\u0026gt; B = { def convert(a: A): B = recompose(decompose(a).map(convert)) convert _ } And voila, a converter in just 1 lines of code:\ndef json2xml(json: JsValue): String =\u0026gt; Elem = hylo(jsValue2JsLike, jsLike2xml).apply(json) The way back is only a bit more involving. This time we require F to be Traverse and the function decomposeA to be of type A =\u0026gt; M[F[A]] for some monad M:\ntrait WayBack { type A type B type F[_] implicit val fHasTraverse: Traverse[F] type M[_] implicit val mIsAMonad: Monad[M] val decomposeA: A =\u0026gt; M[F[A]] val recomposeB: F[B] =\u0026gt; B final def convert(a: A): M[B] = for { fa \u0026lt;- decomposeA(a) fb \u0026lt;- fa.traverse(convert) } yield recomposeB(fb) } Again, in a more compact way:\ndef hyloish[A,B, F[_]: Traverse, M[_]: Monad](decompose: A =\u0026gt; M[F[A]], recompose: F[B] =\u0026gt; B): A =\u0026gt; M[B] = { def convert(a: A): M[B] = for { fa \u0026lt;- decompose(a) fb \u0026lt;- fa.traverse(convert) } yield recompose(fb) convert _ } which gives the way back as the oneliner:\ndef xml2json(f: String =\u0026gt; Elem): TagOpt[JsValue] = hyloish(xml2JsLike, jsLike2JsValue).apply(f) Reorganizing a bit, it leads to the two conversion functions between (String, JsValue) and Elem:\nval json2xmlBetter: ((String, JsValue)) =\u0026gt; Elem = (jsonPlusTag: (String, JsValue)) =\u0026gt; json2xml(jsonPlusTag._2)(jsonPlusTag._1) val xml2jsonBetter: Elem =\u0026gt; TagOpt[(String, JsValue)] = (e: Elem) =\u0026gt; xml2json((s: String) =\u0026gt; e.copy(label = s)).map(e.label -\u0026gt; _) What\u0026rsquo;s the point? Apart from being so much more complicated that the trivial approach, is there some benefits? Actually yes.\n Firstly, given n formats, there are n² converters. Writing and testing n² functions is a lot of tedious and error-prone work. But if you find some common operations F[_], you only need 2n functions (one X =\u0026gt; F[X] and one F[X] =\u0026gt; X for each format X) to achieve the same goal. Furthermore, each of those functions will be easier to test, which is not to neglect. Secondly, algebras (functions X =\u0026gt; F[X]) and coalgebras (functions F[X] =\u0026gt; X) operate one level at a time. They enable to treat format X as if it was an algebraic data type over operations F. Pattern-matching is such a nice feature! Thirdly, you can write generic functions taking any type X for which you can provide functions X =\u0026gt; F[X] and F[X] =\u0026gt; X. These functions also have higher chances of being correct because there is less space for unexpected behaviour.  If want to dive deeper in this subject, you can look at Matryoshka, read Functional programming with bananas, lenses, envelopes and barbed wire or any resource on F-Algebras and recursion schemes.\nSolution to exercises JsLike instance for Traverse implicit val jsLikeInstances: Traverse[JsLike] = new Traverse[JsLike] { import cats.Eval def traverse[G[_], A, B](fa: JsLike[A])(f: A =\u0026gt; G[B])( implicit G: Applicative[G]): G[JsLike[B]] = fa match { case Atom(a) =\u0026gt; G.point(Atom(a)) case Arr(a) =\u0026gt; a.traverse[G, B](f).map(Arr(_)) case Obj(m) =\u0026gt; m.toList .traverse[G, (String, B)] { case (s, a) =\u0026gt; f(a).map(s -\u0026gt; _) } .map(i =\u0026gt; Obj(i.toMap)) } def foldLeft[A, B](fa: JsLike[A], b: B)(f: (B, A) =\u0026gt; B): B = fa match { case Atom(_) =\u0026gt; b case Arr(a) =\u0026gt; a.foldLeft(b)(f) case Obj(m) =\u0026gt; m.values.foldLeft(b)(f) } def foldRight[A, B](fa: JsLike[A], lb: Eval[B])( f: (A, Eval[B]) =\u0026gt; Eval[B]): Eval[B] = fa match { case Atom(_) =\u0026gt; lb case Arr(a) =\u0026gt; a.foldRight(lb)(f) case Obj(m) =\u0026gt; m.values.foldRight(lb)(f) } } xml2JsLike def xml2JsLike(f: String =\u0026gt; Elem): TagOpt[JsLike[String =\u0026gt; Elem]] = ReaderT[Option, String, JsLike[String =\u0026gt; Elem]] { (s: String) =\u0026gt; val elem: Elem = f(s) elem .attributes .asAttrMap .get(\u0026#34;type\u0026#34;) .flatMap[JsLike[String =\u0026gt; Elem]] { case \u0026#34;null\u0026#34; =\u0026gt; Some(Atom(Null)) case \u0026#34;boolean\u0026#34; =\u0026gt; elem.text match { case \u0026#34;true\u0026#34; =\u0026gt; Some(Atom(Bool(true))) case \u0026#34;false\u0026#34; =\u0026gt; Some(Atom(Bool(false))) case _ =\u0026gt; None } case \u0026#34;number\u0026#34; =\u0026gt; import scala.util.Try Try(BigDecimal(elem.text)) .toOption .map(n =\u0026gt; Atom(Number(n))) case \u0026#34;string\u0026#34; =\u0026gt; Some(Atom(Str(elem.text))) case \u0026#34;array\u0026#34; =\u0026gt; Some(Arr( elem .child .toList .flatMap { case e: Elem =\u0026gt; List((s: String) =\u0026gt; e.copy(label = s)) case _ =\u0026gt; Nil } )) case \u0026#34;object\u0026#34; =\u0026gt; Some(Obj( elem .child .toList .flatMap { case e: Elem =\u0026gt; List(e.label -\u0026gt; ((s: String) =\u0026gt; e.copy(label = s))) case _ =\u0026gt; Nil }.toMap )) case _ =\u0026gt; None } }"
},
{
	"uri": "/hugo/posts/falgebra_scalaio_2017/",
	"title": "F-Algebra talk at ScalaIO 2017: Modéliser astucieusement vos données",
	"tags": [],
	"description": "",
	"content": "I had the chance to present a talk about F-Algebras at ScalaIO 2017. The slides of the presentation are here.\n"
},
{
	"uri": "/hugo/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " @chrilves\u0026rsquo; Archives Have to a look to Posts or navigate with the left bar.\n"
},
{
	"uri": "/hugo/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/hugo/posts/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/hugo/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]